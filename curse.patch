diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/arch/sh/boot/compressed/vmlinux.scr linux-2.6.37.4/arch/sh/boot/compressed/vmlinux.scr
--- linux-2.6.37.4-orig/arch/sh/boot/compressed/vmlinux.scr	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/arch/sh/boot/compressed/vmlinux.scr	1970-01-01 02:00:00.000000000 +0200
@@ -1,10 +0,0 @@
-SECTIONS
-{
-  .rodata..compressed : {
-	input_len = .;
-	LONG(input_data_end - input_data) input_data = .;
-	*(.data)
-	output_len = . - 4;
-	input_data_end = .;
-	}
-}
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/arch/sh/boot/romimage/vmlinux.scr linux-2.6.37.4/arch/sh/boot/romimage/vmlinux.scr
--- linux-2.6.37.4-orig/arch/sh/boot/romimage/vmlinux.scr	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/arch/sh/boot/romimage/vmlinux.scr	1970-01-01 02:00:00.000000000 +0200
@@ -1,8 +0,0 @@
-SECTIONS
-{
-  .text : {
-	zero_page_pos = .;
-	*(.data)
-	end_data = .;
-	}
-}
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/arch/um/include/shared/kern_constants.h linux-2.6.37.4/arch/um/include/shared/kern_constants.h
--- linux-2.6.37.4-orig/arch/um/include/shared/kern_constants.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/arch/um/include/shared/kern_constants.h	2012-06-24 16:56:18.000000000 +0300
@@ -0,0 +1 @@
+#include "../../../../include/generated/asm-offsets.h"
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/arch/um/include/shared/user_constants.h linux-2.6.37.4/arch/um/include/shared/user_constants.h
--- linux-2.6.37.4-orig/arch/um/include/shared/user_constants.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/arch/um/include/shared/user_constants.h	2012-06-24 16:56:31.000000000 +0300
@@ -0,0 +1,40 @@
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by arch/um/Makefile
+ *
+ */
+
+#define HOST_SC_CR2 176 /* offsetof(struct sigcontext, cr2)	# */
+#define HOST_SC_ERR 152 /* offsetof(struct sigcontext, err)	# */
+#define HOST_SC_TRAPNO 160 /* offsetof(struct sigcontext, trapno)	# */
+#define HOST_FP_SIZE 64 /* sizeof(struct _fpstate) / sizeof(unsigned long)	# */
+#define HOST_RBX 5 /* RBX	# */
+#define HOST_RCX 11 /* RCX	# */
+#define HOST_RDI 14 /* RDI	# */
+#define HOST_RSI 13 /* RSI	# */
+#define HOST_RDX 12 /* RDX	# */
+#define HOST_RBP 4 /* RBP	# */
+#define HOST_RAX 10 /* RAX	# */
+#define HOST_R8 9 /* R8	# */
+#define HOST_R9 8 /* R9	# */
+#define HOST_R10 7 /* R10	# */
+#define HOST_R11 6 /* R11	# */
+#define HOST_R12 3 /* R12	# */
+#define HOST_R13 2 /* R13	# */
+#define HOST_R14 1 /* R14	# */
+#define HOST_R15 0 /* R15	# */
+#define HOST_ORIG_RAX 15 /* ORIG_RAX	# */
+#define HOST_CS 17 /* CS	# */
+#define HOST_SS 20 /* SS	# */
+#define HOST_EFLAGS 18 /* EFLAGS	# */
+#define HOST_IP 16 /* RIP	# */
+#define HOST_SP 19 /* RSP	# */
+#define UM_FRAME_SIZE 216 /* sizeof(struct user_regs_struct)	# */
+#define UM_POLLIN 1 /* POLLIN	# */
+#define UM_POLLPRI 2 /* POLLPRI	# */
+#define UM_POLLOUT 4 /* POLLOUT	# */
+#define UM_PROT_READ 1 /* PROT_READ	# */
+#define UM_PROT_WRITE 2 /* PROT_WRITE	# */
+#define UM_PROT_EXEC 4 /* PROT_EXEC	# */
+
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/arch/um/Kconfig.rest linux-2.6.37.4/arch/um/Kconfig.rest
--- linux-2.6.37.4-orig/arch/um/Kconfig.rest	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/arch/um/Kconfig.rest	2012-06-21 22:30:11.000000000 +0300
@@ -22,6 +22,8 @@ source "security/Kconfig"
 
 source "crypto/Kconfig"
 
+source "curse_imp/Kconfig"
+
 source "lib/Kconfig"
 
 source "drivers/scsi/Kconfig"
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/arch/um/kernel/config.c linux-2.6.37.4/arch/um/kernel/config.c
--- linux-2.6.37.4-orig/arch/um/kernel/config.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/arch/um/kernel/config.c	2012-06-21 22:30:11.000000000 +0300
@@ -0,0 +1,797 @@
+/* 
+ * Copyright (C) 2002 Jeff Dike (jdike@karaya.com)
+ * Licensed under the GPL
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "init.h"
+
+static __initdata const char *config[] = {
+
+"#\n",
+"# Automatically generated make config: don't edit\n",
+"# Linux Kernel Configuration\n",
+"# Wed May 30 00:51:04 2012\n",
+"#\n",
+"CONFIG_DEFCONFIG_LIST=\"arch/$ARCH/defconfig\"\n",
+"CONFIG_GENERIC_HARDIRQS=y\n",
+"CONFIG_UML=y\n",
+"CONFIG_MMU=y\n",
+"CONFIG_NO_IOMEM=y\n",
+"# CONFIG_TRACE_IRQFLAGS_SUPPORT is not set\n",
+"CONFIG_LOCKDEP_SUPPORT=y\n",
+"# CONFIG_STACKTRACE_SUPPORT is not set\n",
+"CONFIG_GENERIC_CALIBRATE_DELAY=y\n",
+"CONFIG_GENERIC_BUG=y\n",
+"CONFIG_GENERIC_CLOCKEVENTS=y\n",
+"CONFIG_IRQ_RELEASE_METHOD=y\n",
+"CONFIG_HZ=100\n",
+"\n",
+"#\n",
+"# UML-specific options\n",
+"#\n",
+"\n",
+"#\n",
+"# Host processor type and features\n",
+"#\n",
+"# CONFIG_M486 is not set\n",
+"# CONFIG_M586 is not set\n",
+"# CONFIG_M586TSC is not set\n",
+"# CONFIG_M586MMX is not set\n",
+"CONFIG_M686=y\n",
+"# CONFIG_MPENTIUMII is not set\n",
+"# CONFIG_MPENTIUMIII is not set\n",
+"# CONFIG_MPENTIUMM is not set\n",
+"# CONFIG_MPENTIUM4 is not set\n",
+"# CONFIG_MK6 is not set\n",
+"# CONFIG_MK7 is not set\n",
+"# CONFIG_MK8 is not set\n",
+"# CONFIG_MCRUSOE is not set\n",
+"# CONFIG_MEFFICEON is not set\n",
+"# CONFIG_MWINCHIPC6 is not set\n",
+"# CONFIG_MWINCHIP3D is not set\n",
+"# CONFIG_MGEODEGX1 is not set\n",
+"# CONFIG_MGEODE_LX is not set\n",
+"# CONFIG_MCYRIXIII is not set\n",
+"# CONFIG_MVIAC3_2 is not set\n",
+"# CONFIG_MVIAC7 is not set\n",
+"# CONFIG_MCORE2 is not set\n",
+"# CONFIG_MATOM is not set\n",
+"# CONFIG_X86_GENERIC is not set\n",
+"CONFIG_X86_CPU=y\n",
+"CONFIG_X86_INTERNODE_CACHE_SHIFT=5\n",
+"CONFIG_X86_CMPXCHG=y\n",
+"CONFIG_X86_L1_CACHE_SHIFT=5\n",
+"CONFIG_X86_XADD=y\n",
+"CONFIG_X86_PPRO_FENCE=y\n",
+"CONFIG_X86_WP_WORKS_OK=y\n",
+"CONFIG_X86_INVLPG=y\n",
+"CONFIG_X86_BSWAP=y\n",
+"CONFIG_X86_POPAD_OK=y\n",
+"CONFIG_X86_USE_PPRO_CHECKSUM=y\n",
+"CONFIG_X86_TSC=y\n",
+"CONFIG_X86_CMPXCHG64=y\n",
+"CONFIG_X86_CMOV=y\n",
+"CONFIG_X86_MINIMUM_CPU_FAMILY=5\n",
+"CONFIG_CPU_SUP_INTEL=y\n",
+"CONFIG_CPU_SUP_CYRIX_32=y\n",
+"CONFIG_CPU_SUP_AMD=y\n",
+"CONFIG_CPU_SUP_CENTAUR=y\n",
+"CONFIG_CPU_SUP_TRANSMETA_32=y\n",
+"CONFIG_CPU_SUP_UMC_32=y\n",
+"CONFIG_UML_X86=y\n",
+"# CONFIG_64BIT is not set\n",
+"CONFIG_X86_32=y\n",
+"CONFIG_RWSEM_XCHGADD_ALGORITHM=y\n",
+"# CONFIG_RWSEM_GENERIC_SPINLOCK is not set\n",
+"# CONFIG_3_LEVEL_PGTABLES is not set\n",
+"CONFIG_ARCH_HAS_SC_SIGNALS=y\n",
+"CONFIG_ARCH_REUSE_HOST_VSYSCALL_AREA=y\n",
+"# CONFIG_SMP_BROKEN is not set\n",
+"CONFIG_GENERIC_HWEIGHT=y\n",
+"# CONFIG_STATIC_LINK is not set\n",
+"CONFIG_SELECT_MEMORY_MODEL=y\n",
+"CONFIG_FLATMEM_MANUAL=y\n",
+"CONFIG_FLATMEM=y\n",
+"CONFIG_FLAT_NODE_MEM_MAP=y\n",
+"CONFIG_PAGEFLAGS_EXTENDED=y\n",
+"CONFIG_SPLIT_PTLOCK_CPUS=4\n",
+"# CONFIG_PHYS_ADDR_T_64BIT is not set\n",
+"CONFIG_ZONE_DMA_FLAG=0\n",
+"CONFIG_VIRT_TO_BUS=y\n",
+"# CONFIG_KSM is not set\n",
+"CONFIG_DEFAULT_MMAP_MIN_ADDR=4096\n",
+"CONFIG_NEED_PER_CPU_KM=y\n",
+"CONFIG_TICK_ONESHOT=y\n",
+"CONFIG_NO_HZ=y\n",
+"CONFIG_HIGH_RES_TIMERS=y\n",
+"CONFIG_GENERIC_CLOCKEVENTS_BUILD=y\n",
+"CONFIG_LD_SCRIPT_DYN=y\n",
+"CONFIG_BINFMT_ELF=y\n",
+"CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y\n",
+"CONFIG_HAVE_AOUT=y\n",
+"# CONFIG_BINFMT_AOUT is not set\n",
+"CONFIG_BINFMT_MISC=m\n",
+"CONFIG_HOSTFS=y\n",
+"# CONFIG_HPPFS is not set\n",
+"CONFIG_MCONSOLE=y\n",
+"CONFIG_MAGIC_SYSRQ=y\n",
+"CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y\n",
+"# CONFIG_HIGHMEM is not set\n",
+"CONFIG_KERNEL_STACK_ORDER=0\n",
+"CONFIG_NO_DMA=y\n",
+"\n",
+"#\n",
+"# General setup\n",
+"#\n",
+"CONFIG_EXPERIMENTAL=y\n",
+"CONFIG_BROKEN_ON_SMP=y\n",
+"CONFIG_INIT_ENV_ARG_LIMIT=128\n",
+"CONFIG_CROSS_COMPILE=\"\"\n",
+"CONFIG_LOCALVERSION=\"\"\n",
+"CONFIG_LOCALVERSION_AUTO=y\n",
+"CONFIG_SWAP=y\n",
+"CONFIG_SYSVIPC=y\n",
+"CONFIG_SYSVIPC_SYSCTL=y\n",
+"CONFIG_POSIX_MQUEUE=y\n",
+"CONFIG_POSIX_MQUEUE_SYSCTL=y\n",
+"CONFIG_BSD_PROCESS_ACCT=y\n",
+"# CONFIG_BSD_PROCESS_ACCT_V3 is not set\n",
+"# CONFIG_TASKSTATS is not set\n",
+"# CONFIG_AUDIT is not set\n",
+"# CONFIG_HAVE_GENERIC_HARDIRQS is not set\n",
+"\n",
+"#\n",
+"# RCU Subsystem\n",
+"#\n",
+"CONFIG_TINY_RCU=y\n",
+"# CONFIG_PREEMPT_RCU is not set\n",
+"# CONFIG_TREE_RCU_TRACE is not set\n",
+"CONFIG_IKCONFIG=y\n",
+"CONFIG_IKCONFIG_PROC=y\n",
+"CONFIG_LOG_BUF_SHIFT=14\n",
+"# CONFIG_CGROUPS is not set\n",
+"CONFIG_NAMESPACES=y\n",
+"CONFIG_UTS_NS=y\n",
+"CONFIG_IPC_NS=y\n",
+"# CONFIG_USER_NS is not set\n",
+"# CONFIG_PID_NS is not set\n",
+"CONFIG_NET_NS=y\n",
+"CONFIG_SYSFS_DEPRECATED=y\n",
+"# CONFIG_SYSFS_DEPRECATED_V2 is not set\n",
+"# CONFIG_RELAY is not set\n",
+"# CONFIG_BLK_DEV_INITRD is not set\n",
+"CONFIG_CC_OPTIMIZE_FOR_SIZE=y\n",
+"CONFIG_SYSCTL=y\n",
+"CONFIG_ANON_INODES=y\n",
+"# CONFIG_EMBEDDED is not set\n",
+"CONFIG_UID16=y\n",
+"CONFIG_SYSCTL_SYSCALL=y\n",
+"CONFIG_KALLSYMS=y\n",
+"# CONFIG_KALLSYMS_ALL is not set\n",
+"CONFIG_KALLSYMS_EXTRA_PASS=y\n",
+"CONFIG_HOTPLUG=y\n",
+"CONFIG_PRINTK=y\n",
+"CONFIG_BUG=y\n",
+"CONFIG_ELF_CORE=y\n",
+"CONFIG_BASE_FULL=y\n",
+"CONFIG_FUTEX=y\n",
+"CONFIG_EPOLL=y\n",
+"CONFIG_SIGNALFD=y\n",
+"CONFIG_TIMERFD=y\n",
+"CONFIG_EVENTFD=y\n",
+"CONFIG_SHMEM=y\n",
+"CONFIG_AIO=y\n",
+"\n",
+"#\n",
+"# Kernel Performance Events And Counters\n",
+"#\n",
+"CONFIG_VM_EVENT_COUNTERS=y\n",
+"CONFIG_COMPAT_BRK=y\n",
+"CONFIG_SLAB=y\n",
+"# CONFIG_SLUB is not set\n",
+"# CONFIG_PROFILING is not set\n",
+"\n",
+"#\n",
+"# GCOV-based kernel profiling\n",
+"#\n",
+"# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set\n",
+"CONFIG_SLABINFO=y\n",
+"CONFIG_RT_MUTEXES=y\n",
+"CONFIG_BASE_SMALL=0\n",
+"CONFIG_MODULES=y\n",
+"# CONFIG_MODULE_FORCE_LOAD is not set\n",
+"CONFIG_MODULE_UNLOAD=y\n",
+"# CONFIG_MODULE_FORCE_UNLOAD is not set\n",
+"# CONFIG_MODVERSIONS is not set\n",
+"# CONFIG_MODULE_SRCVERSION_ALL is not set\n",
+"CONFIG_BLOCK=y\n",
+"CONFIG_LBDAF=y\n",
+"# CONFIG_BLK_DEV_BSG is not set\n",
+"# CONFIG_BLK_DEV_INTEGRITY is not set\n",
+"\n",
+"#\n",
+"# IO Schedulers\n",
+"#\n",
+"CONFIG_IOSCHED_NOOP=y\n",
+"CONFIG_IOSCHED_DEADLINE=y\n",
+"CONFIG_IOSCHED_CFQ=y\n",
+"# CONFIG_DEFAULT_DEADLINE is not set\n",
+"CONFIG_DEFAULT_CFQ=y\n",
+"# CONFIG_DEFAULT_NOOP is not set\n",
+"CONFIG_DEFAULT_IOSCHED=\"cfq\"\n",
+"# CONFIG_INLINE_SPIN_TRYLOCK is not set\n",
+"# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set\n",
+"# CONFIG_INLINE_SPIN_LOCK is not set\n",
+"# CONFIG_INLINE_SPIN_LOCK_BH is not set\n",
+"# CONFIG_INLINE_SPIN_LOCK_IRQ is not set\n",
+"# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set\n",
+"CONFIG_INLINE_SPIN_UNLOCK=y\n",
+"# CONFIG_INLINE_SPIN_UNLOCK_BH is not set\n",
+"CONFIG_INLINE_SPIN_UNLOCK_IRQ=y\n",
+"# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set\n",
+"# CONFIG_INLINE_READ_TRYLOCK is not set\n",
+"# CONFIG_INLINE_READ_LOCK is not set\n",
+"# CONFIG_INLINE_READ_LOCK_BH is not set\n",
+"# CONFIG_INLINE_READ_LOCK_IRQ is not set\n",
+"# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set\n",
+"CONFIG_INLINE_READ_UNLOCK=y\n",
+"# CONFIG_INLINE_READ_UNLOCK_BH is not set\n",
+"CONFIG_INLINE_READ_UNLOCK_IRQ=y\n",
+"# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set\n",
+"# CONFIG_INLINE_WRITE_TRYLOCK is not set\n",
+"# CONFIG_INLINE_WRITE_LOCK is not set\n",
+"# CONFIG_INLINE_WRITE_LOCK_BH is not set\n",
+"# CONFIG_INLINE_WRITE_LOCK_IRQ is not set\n",
+"# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set\n",
+"CONFIG_INLINE_WRITE_UNLOCK=y\n",
+"# CONFIG_INLINE_WRITE_UNLOCK_BH is not set\n",
+"CONFIG_INLINE_WRITE_UNLOCK_IRQ=y\n",
+"# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set\n",
+"# CONFIG_MUTEX_SPIN_ON_OWNER is not set\n",
+"# CONFIG_FREEZER is not set\n",
+"CONFIG_BLK_DEV=y\n",
+"CONFIG_BLK_DEV_UBD=y\n",
+"# CONFIG_BLK_DEV_UBD_SYNC is not set\n",
+"CONFIG_BLK_DEV_COW_COMMON=y\n",
+"CONFIG_BLK_DEV_LOOP=m\n",
+"# CONFIG_BLK_DEV_CRYPTOLOOP is not set\n",
+"\n",
+"#\n",
+"# DRBD disabled because PROC_FS, INET or CONNECTOR not selected\n",
+"#\n",
+"CONFIG_BLK_DEV_NBD=m\n",
+"# CONFIG_BLK_DEV_RAM is not set\n",
+"# CONFIG_ATA_OVER_ETH is not set\n",
+"# CONFIG_BLK_DEV_RBD is not set\n",
+"\n",
+"#\n",
+"# Character Devices\n",
+"#\n",
+"CONFIG_STDERR_CONSOLE=y\n",
+"CONFIG_STDIO_CONSOLE=y\n",
+"CONFIG_SSL=y\n",
+"CONFIG_NULL_CHAN=y\n",
+"CONFIG_PORT_CHAN=y\n",
+"CONFIG_PTY_CHAN=y\n",
+"CONFIG_TTY_CHAN=y\n",
+"CONFIG_XTERM_CHAN=y\n",
+"# CONFIG_NOCONFIG_CHAN is not set\n",
+"CONFIG_CON_ZERO_CHAN=\"fd:0,fd:1\"\n",
+"CONFIG_CON_CHAN=\"xterm\"\n",
+"CONFIG_SSL_CHAN=\"pts\"\n",
+"CONFIG_UNIX98_PTYS=y\n",
+"CONFIG_LEGACY_PTYS=y\n",
+"# CONFIG_RAW_DRIVER is not set\n",
+"CONFIG_LEGACY_PTY_COUNT=32\n",
+"# CONFIG_WATCHDOG is not set\n",
+"CONFIG_UML_SOUND=m\n",
+"CONFIG_SOUND=m\n",
+"CONFIG_SOUND_OSS_CORE=y\n",
+"CONFIG_HOSTAUDIO=m\n",
+"# CONFIG_HW_RANDOM is not set\n",
+"CONFIG_UML_RANDOM=y\n",
+"# CONFIG_MMAPPER is not set\n",
+"\n",
+"#\n",
+"# Generic Driver Options\n",
+"#\n",
+"CONFIG_UEVENT_HELPER_PATH=\"/sbin/hotplug\"\n",
+"# CONFIG_DEVTMPFS is not set\n",
+"CONFIG_STANDALONE=y\n",
+"CONFIG_PREVENT_FIRMWARE_BUILD=y\n",
+"CONFIG_FW_LOADER=y\n",
+"CONFIG_FIRMWARE_IN_KERNEL=y\n",
+"CONFIG_EXTRA_FIRMWARE=\"\"\n",
+"# CONFIG_DEBUG_DRIVER is not set\n",
+"# CONFIG_DEBUG_DEVRES is not set\n",
+"# CONFIG_SYS_HYPERVISOR is not set\n",
+"CONFIG_NET=y\n",
+"\n",
+"#\n",
+"# Networking options\n",
+"#\n",
+"CONFIG_PACKET=y\n",
+"CONFIG_UNIX=y\n",
+"CONFIG_XFRM=y\n",
+"# CONFIG_XFRM_USER is not set\n",
+"# CONFIG_XFRM_SUB_POLICY is not set\n",
+"# CONFIG_XFRM_MIGRATE is not set\n",
+"# CONFIG_XFRM_STATISTICS is not set\n",
+"# CONFIG_NET_KEY is not set\n",
+"CONFIG_INET=y\n",
+"# CONFIG_IP_MULTICAST is not set\n",
+"# CONFIG_IP_ADVANCED_ROUTER is not set\n",
+"CONFIG_IP_FIB_HASH=y\n",
+"# CONFIG_IP_PNP is not set\n",
+"# CONFIG_NET_IPIP is not set\n",
+"# CONFIG_NET_IPGRE_DEMUX is not set\n",
+"# CONFIG_ARPD is not set\n",
+"# CONFIG_SYN_COOKIES is not set\n",
+"# CONFIG_INET_AH is not set\n",
+"# CONFIG_INET_ESP is not set\n",
+"# CONFIG_INET_IPCOMP is not set\n",
+"# CONFIG_INET_XFRM_TUNNEL is not set\n",
+"# CONFIG_INET_TUNNEL is not set\n",
+"CONFIG_INET_XFRM_MODE_TRANSPORT=y\n",
+"CONFIG_INET_XFRM_MODE_TUNNEL=y\n",
+"CONFIG_INET_XFRM_MODE_BEET=y\n",
+"# CONFIG_INET_LRO is not set\n",
+"CONFIG_INET_DIAG=y\n",
+"CONFIG_INET_TCP_DIAG=y\n",
+"# CONFIG_TCP_CONG_ADVANCED is not set\n",
+"CONFIG_TCP_CONG_CUBIC=y\n",
+"CONFIG_DEFAULT_TCP_CONG=\"cubic\"\n",
+"# CONFIG_TCP_MD5SIG is not set\n",
+"# CONFIG_IPV6 is not set\n",
+"# CONFIG_NETWORK_SECMARK is not set\n",
+"# CONFIG_NETWORK_PHY_TIMESTAMPING is not set\n",
+"# CONFIG_NETFILTER is not set\n",
+"# CONFIG_IP_DCCP is not set\n",
+"# CONFIG_IP_SCTP is not set\n",
+"# CONFIG_RDS is not set\n",
+"# CONFIG_TIPC is not set\n",
+"# CONFIG_ATM is not set\n",
+"# CONFIG_L2TP is not set\n",
+"# CONFIG_BRIDGE is not set\n",
+"# CONFIG_NET_DSA is not set\n",
+"# CONFIG_VLAN_8021Q is not set\n",
+"# CONFIG_DECNET is not set\n",
+"# CONFIG_LLC2 is not set\n",
+"# CONFIG_IPX is not set\n",
+"# CONFIG_ATALK is not set\n",
+"# CONFIG_X25 is not set\n",
+"# CONFIG_LAPB is not set\n",
+"# CONFIG_ECONET is not set\n",
+"# CONFIG_WAN_ROUTER is not set\n",
+"# CONFIG_PHONET is not set\n",
+"# CONFIG_IEEE802154 is not set\n",
+"# CONFIG_NET_SCHED is not set\n",
+"# CONFIG_DCB is not set\n",
+"\n",
+"#\n",
+"# Network testing\n",
+"#\n",
+"# CONFIG_NET_PKTGEN is not set\n",
+"# CONFIG_HAMRADIO is not set\n",
+"# CONFIG_CAN is not set\n",
+"# CONFIG_IRDA is not set\n",
+"# CONFIG_BT is not set\n",
+"# CONFIG_AF_RXRPC is not set\n",
+"CONFIG_WIRELESS=y\n",
+"# CONFIG_CFG80211 is not set\n",
+"# CONFIG_LIB80211 is not set\n",
+"\n",
+"#\n",
+"# CFG80211 needs to be enabled for MAC80211\n",
+"#\n",
+"\n",
+"#\n",
+"# Some wireless drivers require a rate control algorithm\n",
+"#\n",
+"# CONFIG_WIMAX is not set\n",
+"# CONFIG_RFKILL is not set\n",
+"# CONFIG_NET_9P is not set\n",
+"# CONFIG_CAIF is not set\n",
+"# CONFIG_CEPH_LIB is not set\n",
+"\n",
+"#\n",
+"# UML Network Devices\n",
+"#\n",
+"CONFIG_UML_NET=y\n",
+"CONFIG_UML_NET_ETHERTAP=y\n",
+"CONFIG_UML_NET_TUNTAP=y\n",
+"CONFIG_UML_NET_SLIP=y\n",
+"CONFIG_UML_NET_DAEMON=y\n",
+"# CONFIG_UML_NET_VDE is not set\n",
+"CONFIG_UML_NET_MCAST=y\n",
+"# CONFIG_UML_NET_PCAP is not set\n",
+"CONFIG_UML_NET_SLIRP=y\n",
+"CONFIG_NETDEVICES=y\n",
+"CONFIG_DUMMY=m\n",
+"# CONFIG_BONDING is not set\n",
+"# CONFIG_MACVLAN is not set\n",
+"# CONFIG_EQUALIZER is not set\n",
+"CONFIG_TUN=m\n",
+"# CONFIG_VETH is not set\n",
+"# CONFIG_MII is not set\n",
+"# CONFIG_PHYLIB is not set\n",
+"CONFIG_WLAN=y\n",
+"# CONFIG_HOSTAP is not set\n",
+"\n",
+"#\n",
+"# Enable WiMAX (Networking options) to see the WiMAX drivers\n",
+"#\n",
+"# CONFIG_WAN is not set\n",
+"\n",
+"#\n",
+"# CAIF transport drivers\n",
+"#\n",
+"CONFIG_PPP=m\n",
+"# CONFIG_PPP_MULTILINK is not set\n",
+"# CONFIG_PPP_FILTER is not set\n",
+"# CONFIG_PPP_ASYNC is not set\n",
+"# CONFIG_PPP_SYNC_TTY is not set\n",
+"# CONFIG_PPP_DEFLATE is not set\n",
+"# CONFIG_PPP_BSDCOMP is not set\n",
+"# CONFIG_PPP_MPPE is not set\n",
+"# CONFIG_PPPOE is not set\n",
+"CONFIG_SLIP=m\n",
+"# CONFIG_SLIP_COMPRESSED is not set\n",
+"CONFIG_SLHC=m\n",
+"# CONFIG_SLIP_SMART is not set\n",
+"# CONFIG_SLIP_MODE_SLIP6 is not set\n",
+"# CONFIG_NETCONSOLE is not set\n",
+"# CONFIG_NETPOLL is not set\n",
+"# CONFIG_NET_POLL_CONTROLLER is not set\n",
+"# CONFIG_CONNECTOR is not set\n",
+"\n",
+"#\n",
+"# File systems\n",
+"#\n",
+"CONFIG_EXT2_FS=y\n",
+"# CONFIG_EXT2_FS_XATTR is not set\n",
+"# CONFIG_EXT2_FS_XIP is not set\n",
+"CONFIG_EXT3_FS=y\n",
+"CONFIG_EXT3_DEFAULTS_TO_ORDERED=y\n",
+"# CONFIG_EXT3_FS_XATTR is not set\n",
+"# CONFIG_EXT4_FS is not set\n",
+"CONFIG_JBD=y\n",
+"CONFIG_REISERFS_FS=y\n",
+"# CONFIG_REISERFS_CHECK is not set\n",
+"# CONFIG_REISERFS_PROC_INFO is not set\n",
+"# CONFIG_REISERFS_FS_XATTR is not set\n",
+"# CONFIG_JFS_FS is not set\n",
+"# CONFIG_FS_POSIX_ACL is not set\n",
+"# CONFIG_XFS_FS is not set\n",
+"# CONFIG_GFS2_FS is not set\n",
+"# CONFIG_OCFS2_FS is not set\n",
+"# CONFIG_BTRFS_FS is not set\n",
+"# CONFIG_NILFS2_FS is not set\n",
+"CONFIG_FILE_LOCKING=y\n",
+"CONFIG_FSNOTIFY=y\n",
+"CONFIG_DNOTIFY=y\n",
+"CONFIG_INOTIFY_USER=y\n",
+"# CONFIG_FANOTIFY is not set\n",
+"CONFIG_QUOTA=y\n",
+"# CONFIG_QUOTA_NETLINK_INTERFACE is not set\n",
+"CONFIG_PRINT_QUOTA_WARNING=y\n",
+"# CONFIG_QUOTA_DEBUG is not set\n",
+"# CONFIG_QFMT_V1 is not set\n",
+"# CONFIG_QFMT_V2 is not set\n",
+"CONFIG_QUOTACTL=y\n",
+"CONFIG_AUTOFS4_FS=m\n",
+"# CONFIG_FUSE_FS is not set\n",
+"\n",
+"#\n",
+"# Caches\n",
+"#\n",
+"# CONFIG_FSCACHE is not set\n",
+"\n",
+"#\n",
+"# CD-ROM/DVD Filesystems\n",
+"#\n",
+"CONFIG_ISO9660_FS=m\n",
+"CONFIG_JOLIET=y\n",
+"# CONFIG_ZISOFS is not set\n",
+"# CONFIG_UDF_FS is not set\n",
+"\n",
+"#\n",
+"# DOS/FAT/NT Filesystems\n",
+"#\n",
+"# CONFIG_MSDOS_FS is not set\n",
+"# CONFIG_VFAT_FS is not set\n",
+"# CONFIG_NTFS_FS is not set\n",
+"\n",
+"#\n",
+"# Pseudo filesystems\n",
+"#\n",
+"CONFIG_PROC_FS=y\n",
+"CONFIG_PROC_KCORE=y\n",
+"CONFIG_PROC_SYSCTL=y\n",
+"CONFIG_PROC_PAGE_MONITOR=y\n",
+"CONFIG_SYSFS=y\n",
+"CONFIG_TMPFS=y\n",
+"# CONFIG_TMPFS_POSIX_ACL is not set\n",
+"# CONFIG_HUGETLB_PAGE is not set\n",
+"# CONFIG_CONFIGFS_FS is not set\n",
+"CONFIG_MISC_FILESYSTEMS=y\n",
+"# CONFIG_ADFS_FS is not set\n",
+"# CONFIG_AFFS_FS is not set\n",
+"# CONFIG_HFS_FS is not set\n",
+"# CONFIG_HFSPLUS_FS is not set\n",
+"# CONFIG_BEFS_FS is not set\n",
+"# CONFIG_BFS_FS is not set\n",
+"# CONFIG_EFS_FS is not set\n",
+"# CONFIG_LOGFS is not set\n",
+"# CONFIG_CRAMFS is not set\n",
+"# CONFIG_SQUASHFS is not set\n",
+"# CONFIG_VXFS_FS is not set\n",
+"# CONFIG_MINIX_FS is not set\n",
+"# CONFIG_OMFS_FS is not set\n",
+"# CONFIG_HPFS_FS is not set\n",
+"# CONFIG_QNX4FS_FS is not set\n",
+"# CONFIG_ROMFS_FS is not set\n",
+"# CONFIG_SYSV_FS is not set\n",
+"# CONFIG_UFS_FS is not set\n",
+"CONFIG_NETWORK_FILESYSTEMS=y\n",
+"# CONFIG_NFS_FS is not set\n",
+"# CONFIG_NFSD is not set\n",
+"# CONFIG_CEPH_FS is not set\n",
+"# CONFIG_CIFS is not set\n",
+"# CONFIG_NCP_FS is not set\n",
+"# CONFIG_CODA_FS is not set\n",
+"# CONFIG_AFS_FS is not set\n",
+"\n",
+"#\n",
+"# Partition Types\n",
+"#\n",
+"# CONFIG_PARTITION_ADVANCED is not set\n",
+"CONFIG_MSDOS_PARTITION=y\n",
+"CONFIG_NLS=y\n",
+"CONFIG_NLS_DEFAULT=\"iso8859-1\"\n",
+"# CONFIG_NLS_CODEPAGE_437 is not set\n",
+"# CONFIG_NLS_CODEPAGE_737 is not set\n",
+"# CONFIG_NLS_CODEPAGE_775 is not set\n",
+"# CONFIG_NLS_CODEPAGE_850 is not set\n",
+"# CONFIG_NLS_CODEPAGE_852 is not set\n",
+"# CONFIG_NLS_CODEPAGE_855 is not set\n",
+"# CONFIG_NLS_CODEPAGE_857 is not set\n",
+"# CONFIG_NLS_CODEPAGE_860 is not set\n",
+"# CONFIG_NLS_CODEPAGE_861 is not set\n",
+"# CONFIG_NLS_CODEPAGE_862 is not set\n",
+"# CONFIG_NLS_CODEPAGE_863 is not set\n",
+"# CONFIG_NLS_CODEPAGE_864 is not set\n",
+"# CONFIG_NLS_CODEPAGE_865 is not set\n",
+"# CONFIG_NLS_CODEPAGE_866 is not set\n",
+"# CONFIG_NLS_CODEPAGE_869 is not set\n",
+"# CONFIG_NLS_CODEPAGE_936 is not set\n",
+"# CONFIG_NLS_CODEPAGE_950 is not set\n",
+"# CONFIG_NLS_CODEPAGE_932 is not set\n",
+"# CONFIG_NLS_CODEPAGE_949 is not set\n",
+"# CONFIG_NLS_CODEPAGE_874 is not set\n",
+"# CONFIG_NLS_ISO8859_8 is not set\n",
+"# CONFIG_NLS_CODEPAGE_1250 is not set\n",
+"# CONFIG_NLS_CODEPAGE_1251 is not set\n",
+"# CONFIG_NLS_ASCII is not set\n",
+"# CONFIG_NLS_ISO8859_1 is not set\n",
+"# CONFIG_NLS_ISO8859_2 is not set\n",
+"# CONFIG_NLS_ISO8859_3 is not set\n",
+"# CONFIG_NLS_ISO8859_4 is not set\n",
+"# CONFIG_NLS_ISO8859_5 is not set\n",
+"# CONFIG_NLS_ISO8859_6 is not set\n",
+"# CONFIG_NLS_ISO8859_7 is not set\n",
+"# CONFIG_NLS_ISO8859_9 is not set\n",
+"# CONFIG_NLS_ISO8859_13 is not set\n",
+"# CONFIG_NLS_ISO8859_14 is not set\n",
+"# CONFIG_NLS_ISO8859_15 is not set\n",
+"# CONFIG_NLS_KOI8_R is not set\n",
+"# CONFIG_NLS_KOI8_U is not set\n",
+"# CONFIG_NLS_UTF8 is not set\n",
+"# CONFIG_DLM is not set\n",
+"\n",
+"#\n",
+"# Security options\n",
+"#\n",
+"# CONFIG_KEYS is not set\n",
+"# CONFIG_SECURITY_DMESG_RESTRICT is not set\n",
+"# CONFIG_SECURITY is not set\n",
+"# CONFIG_SECURITYFS is not set\n",
+"CONFIG_DEFAULT_SECURITY_DAC=y\n",
+"CONFIG_DEFAULT_SECURITY=\"\"\n",
+"CONFIG_CRYPTO=y\n",
+"\n",
+"#\n",
+"# Crypto core or helper\n",
+"#\n",
+"# CONFIG_CRYPTO_FIPS is not set\n",
+"CONFIG_CRYPTO_ALGAPI=m\n",
+"CONFIG_CRYPTO_ALGAPI2=m\n",
+"CONFIG_CRYPTO_RNG=m\n",
+"CONFIG_CRYPTO_RNG2=m\n",
+"# CONFIG_CRYPTO_MANAGER is not set\n",
+"# CONFIG_CRYPTO_MANAGER2 is not set\n",
+"# CONFIG_CRYPTO_GF128MUL is not set\n",
+"# CONFIG_CRYPTO_NULL is not set\n",
+"# CONFIG_CRYPTO_CRYPTD is not set\n",
+"# CONFIG_CRYPTO_AUTHENC is not set\n",
+"# CONFIG_CRYPTO_TEST is not set\n",
+"\n",
+"#\n",
+"# Authenticated Encryption with Associated Data\n",
+"#\n",
+"# CONFIG_CRYPTO_CCM is not set\n",
+"# CONFIG_CRYPTO_GCM is not set\n",
+"# CONFIG_CRYPTO_SEQIV is not set\n",
+"\n",
+"#\n",
+"# Block modes\n",
+"#\n",
+"# CONFIG_CRYPTO_CBC is not set\n",
+"# CONFIG_CRYPTO_CTR is not set\n",
+"# CONFIG_CRYPTO_CTS is not set\n",
+"# CONFIG_CRYPTO_ECB is not set\n",
+"# CONFIG_CRYPTO_LRW is not set\n",
+"# CONFIG_CRYPTO_PCBC is not set\n",
+"# CONFIG_CRYPTO_XTS is not set\n",
+"\n",
+"#\n",
+"# Hash modes\n",
+"#\n",
+"# CONFIG_CRYPTO_HMAC is not set\n",
+"# CONFIG_CRYPTO_XCBC is not set\n",
+"# CONFIG_CRYPTO_VMAC is not set\n",
+"\n",
+"#\n",
+"# Digest\n",
+"#\n",
+"# CONFIG_CRYPTO_CRC32C is not set\n",
+"# CONFIG_CRYPTO_GHASH is not set\n",
+"# CONFIG_CRYPTO_MD4 is not set\n",
+"# CONFIG_CRYPTO_MD5 is not set\n",
+"# CONFIG_CRYPTO_MICHAEL_MIC is not set\n",
+"# CONFIG_CRYPTO_RMD128 is not set\n",
+"# CONFIG_CRYPTO_RMD160 is not set\n",
+"# CONFIG_CRYPTO_RMD256 is not set\n",
+"# CONFIG_CRYPTO_RMD320 is not set\n",
+"# CONFIG_CRYPTO_SHA1 is not set\n",
+"# CONFIG_CRYPTO_SHA256 is not set\n",
+"# CONFIG_CRYPTO_SHA512 is not set\n",
+"# CONFIG_CRYPTO_TGR192 is not set\n",
+"# CONFIG_CRYPTO_WP512 is not set\n",
+"\n",
+"#\n",
+"# Ciphers\n",
+"#\n",
+"CONFIG_CRYPTO_AES=m\n",
+"# CONFIG_CRYPTO_AES_586 is not set\n",
+"# CONFIG_CRYPTO_ANUBIS is not set\n",
+"# CONFIG_CRYPTO_ARC4 is not set\n",
+"# CONFIG_CRYPTO_BLOWFISH is not set\n",
+"# CONFIG_CRYPTO_CAMELLIA is not set\n",
+"# CONFIG_CRYPTO_CAST5 is not set\n",
+"# CONFIG_CRYPTO_CAST6 is not set\n",
+"# CONFIG_CRYPTO_DES is not set\n",
+"# CONFIG_CRYPTO_FCRYPT is not set\n",
+"# CONFIG_CRYPTO_KHAZAD is not set\n",
+"# CONFIG_CRYPTO_SALSA20 is not set\n",
+"# CONFIG_CRYPTO_SALSA20_586 is not set\n",
+"# CONFIG_CRYPTO_SEED is not set\n",
+"# CONFIG_CRYPTO_SERPENT is not set\n",
+"# CONFIG_CRYPTO_TEA is not set\n",
+"# CONFIG_CRYPTO_TWOFISH is not set\n",
+"# CONFIG_CRYPTO_TWOFISH_586 is not set\n",
+"\n",
+"#\n",
+"# Compression\n",
+"#\n",
+"# CONFIG_CRYPTO_DEFLATE is not set\n",
+"# CONFIG_CRYPTO_ZLIB is not set\n",
+"# CONFIG_CRYPTO_LZO is not set\n",
+"\n",
+"#\n",
+"# Random Number Generation\n",
+"#\n",
+"CONFIG_CRYPTO_ANSI_CPRNG=m\n",
+"CONFIG_CRYPTO_HW=y\n",
+"# CONFIG_BINARY_PRINTF is not set\n",
+"\n",
+"#\n",
+"# Library routines\n",
+"#\n",
+"CONFIG_BITREVERSE=y\n",
+"CONFIG_GENERIC_FIND_FIRST_BIT=y\n",
+"CONFIG_GENERIC_FIND_NEXT_BIT=y\n",
+"CONFIG_GENERIC_FIND_LAST_BIT=y\n",
+"# CONFIG_CRC_CCITT is not set\n",
+"# CONFIG_CRC16 is not set\n",
+"# CONFIG_CRC_T10DIF is not set\n",
+"# CONFIG_CRC_ITU_T is not set\n",
+"CONFIG_CRC32=y\n",
+"# CONFIG_CRC7 is not set\n",
+"# CONFIG_LIBCRC32C is not set\n",
+"CONFIG_NLATTR=y\n",
+"\n",
+"#\n",
+"# SCSI device support\n",
+"#\n",
+"CONFIG_SCSI_MOD=y\n",
+"# CONFIG_RAID_ATTRS is not set\n",
+"# CONFIG_SCSI is not set\n",
+"# CONFIG_SCSI_DMA is not set\n",
+"# CONFIG_SCSI_NETLINK is not set\n",
+"# CONFIG_MD is not set\n",
+"# CONFIG_NEW_LEDS is not set\n",
+"# CONFIG_INPUT is not set\n",
+"\n",
+"#\n",
+"# Kernel hacking\n",
+"#\n",
+"# CONFIG_PRINTK_TIME is not set\n",
+"CONFIG_ENABLE_WARN_DEPRECATED=y\n",
+"CONFIG_ENABLE_MUST_CHECK=y\n",
+"CONFIG_FRAME_WARN=1024\n",
+"# CONFIG_STRIP_ASM_SYMS is not set\n",
+"# CONFIG_UNUSED_SYMBOLS is not set\n",
+"# CONFIG_DEBUG_FS is not set\n",
+"CONFIG_DEBUG_KERNEL=y\n",
+"# CONFIG_DEBUG_SHIRQ is not set\n",
+"# CONFIG_LOCKUP_DETECTOR is not set\n",
+"# CONFIG_HARDLOCKUP_DETECTOR is not set\n",
+"# CONFIG_DETECT_HUNG_TASK is not set\n",
+"CONFIG_SCHED_DEBUG=y\n",
+"# CONFIG_SCHEDSTATS is not set\n",
+"# CONFIG_TIMER_STATS is not set\n",
+"# CONFIG_DEBUG_OBJECTS is not set\n",
+"# CONFIG_DEBUG_SLAB is not set\n",
+"# CONFIG_DEBUG_RT_MUTEXES is not set\n",
+"# CONFIG_RT_MUTEX_TESTER is not set\n",
+"# CONFIG_DEBUG_SPINLOCK is not set\n",
+"# CONFIG_DEBUG_MUTEXES is not set\n",
+"CONFIG_BKL=y\n",
+"# CONFIG_SPARSE_RCU_POINTER is not set\n",
+"# CONFIG_DEBUG_SPINLOCK_SLEEP is not set\n",
+"# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set\n",
+"# CONFIG_DEBUG_KOBJECT is not set\n",
+"CONFIG_DEBUG_BUGVERBOSE=y\n",
+"CONFIG_DEBUG_INFO=y\n",
+"# CONFIG_DEBUG_INFO_REDUCED is not set\n",
+"# CONFIG_DEBUG_VM is not set\n",
+"# CONFIG_DEBUG_WRITECOUNT is not set\n",
+"CONFIG_DEBUG_MEMORY_INIT=y\n",
+"# CONFIG_DEBUG_LIST is not set\n",
+"# CONFIG_TEST_LIST_SORT is not set\n",
+"# CONFIG_DEBUG_SG is not set\n",
+"# CONFIG_DEBUG_NOTIFIERS is not set\n",
+"# CONFIG_DEBUG_CREDENTIALS is not set\n",
+"CONFIG_FRAME_POINTER=y\n",
+"# CONFIG_BOOT_PRINTK_DELAY is not set\n",
+"# CONFIG_RCU_TORTURE_TEST is not set\n",
+"# CONFIG_BACKTRACE_SELF_TEST is not set\n",
+"# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set\n",
+"# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set\n",
+"# CONFIG_FAULT_INJECTION is not set\n",
+"# CONFIG_SYSCTL_SYSCALL_CHECK is not set\n",
+"# CONFIG_PAGE_POISONING is not set\n",
+"# CONFIG_ATOMIC64_SELFTEST is not set\n",
+"# CONFIG_SAMPLES is not set\n",
+"# CONFIG_GPROF is not set\n",
+"# CONFIG_GCOV is not set\n",
+"# CONFIG_DEBUG_STACK_USAGE is not set\n",
+""
+};
+
+static int __init print_config(char *line, int *add)
+{
+	int i;
+	for (i = 0; i < sizeof(config)/sizeof(config[0]); i++)
+		printf("%s", config[i]);
+	exit(0);
+}
+
+__uml_setup("--showconfig", print_config,
+"--showconfig\n"
+"    Prints the config file that this UML binary was generated from.\n\n"
+);
+
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/arch/um/kernel/config.tmp linux-2.6.37.4/arch/um/kernel/config.tmp
--- linux-2.6.37.4-orig/arch/um/kernel/config.tmp	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/arch/um/kernel/config.tmp	2012-06-21 22:30:11.000000000 +0300
@@ -0,0 +1,770 @@
+"#\n",
+"# Automatically generated make config: don't edit\n",
+"# Linux Kernel Configuration\n",
+"# Wed May 30 00:51:04 2012\n",
+"#\n",
+"CONFIG_DEFCONFIG_LIST=\"arch/$ARCH/defconfig\"\n",
+"CONFIG_GENERIC_HARDIRQS=y\n",
+"CONFIG_UML=y\n",
+"CONFIG_MMU=y\n",
+"CONFIG_NO_IOMEM=y\n",
+"# CONFIG_TRACE_IRQFLAGS_SUPPORT is not set\n",
+"CONFIG_LOCKDEP_SUPPORT=y\n",
+"# CONFIG_STACKTRACE_SUPPORT is not set\n",
+"CONFIG_GENERIC_CALIBRATE_DELAY=y\n",
+"CONFIG_GENERIC_BUG=y\n",
+"CONFIG_GENERIC_CLOCKEVENTS=y\n",
+"CONFIG_IRQ_RELEASE_METHOD=y\n",
+"CONFIG_HZ=100\n",
+"\n",
+"#\n",
+"# UML-specific options\n",
+"#\n",
+"\n",
+"#\n",
+"# Host processor type and features\n",
+"#\n",
+"# CONFIG_M486 is not set\n",
+"# CONFIG_M586 is not set\n",
+"# CONFIG_M586TSC is not set\n",
+"# CONFIG_M586MMX is not set\n",
+"CONFIG_M686=y\n",
+"# CONFIG_MPENTIUMII is not set\n",
+"# CONFIG_MPENTIUMIII is not set\n",
+"# CONFIG_MPENTIUMM is not set\n",
+"# CONFIG_MPENTIUM4 is not set\n",
+"# CONFIG_MK6 is not set\n",
+"# CONFIG_MK7 is not set\n",
+"# CONFIG_MK8 is not set\n",
+"# CONFIG_MCRUSOE is not set\n",
+"# CONFIG_MEFFICEON is not set\n",
+"# CONFIG_MWINCHIPC6 is not set\n",
+"# CONFIG_MWINCHIP3D is not set\n",
+"# CONFIG_MGEODEGX1 is not set\n",
+"# CONFIG_MGEODE_LX is not set\n",
+"# CONFIG_MCYRIXIII is not set\n",
+"# CONFIG_MVIAC3_2 is not set\n",
+"# CONFIG_MVIAC7 is not set\n",
+"# CONFIG_MCORE2 is not set\n",
+"# CONFIG_MATOM is not set\n",
+"# CONFIG_X86_GENERIC is not set\n",
+"CONFIG_X86_CPU=y\n",
+"CONFIG_X86_INTERNODE_CACHE_SHIFT=5\n",
+"CONFIG_X86_CMPXCHG=y\n",
+"CONFIG_X86_L1_CACHE_SHIFT=5\n",
+"CONFIG_X86_XADD=y\n",
+"CONFIG_X86_PPRO_FENCE=y\n",
+"CONFIG_X86_WP_WORKS_OK=y\n",
+"CONFIG_X86_INVLPG=y\n",
+"CONFIG_X86_BSWAP=y\n",
+"CONFIG_X86_POPAD_OK=y\n",
+"CONFIG_X86_USE_PPRO_CHECKSUM=y\n",
+"CONFIG_X86_TSC=y\n",
+"CONFIG_X86_CMPXCHG64=y\n",
+"CONFIG_X86_CMOV=y\n",
+"CONFIG_X86_MINIMUM_CPU_FAMILY=5\n",
+"CONFIG_CPU_SUP_INTEL=y\n",
+"CONFIG_CPU_SUP_CYRIX_32=y\n",
+"CONFIG_CPU_SUP_AMD=y\n",
+"CONFIG_CPU_SUP_CENTAUR=y\n",
+"CONFIG_CPU_SUP_TRANSMETA_32=y\n",
+"CONFIG_CPU_SUP_UMC_32=y\n",
+"CONFIG_UML_X86=y\n",
+"# CONFIG_64BIT is not set\n",
+"CONFIG_X86_32=y\n",
+"CONFIG_RWSEM_XCHGADD_ALGORITHM=y\n",
+"# CONFIG_RWSEM_GENERIC_SPINLOCK is not set\n",
+"# CONFIG_3_LEVEL_PGTABLES is not set\n",
+"CONFIG_ARCH_HAS_SC_SIGNALS=y\n",
+"CONFIG_ARCH_REUSE_HOST_VSYSCALL_AREA=y\n",
+"# CONFIG_SMP_BROKEN is not set\n",
+"CONFIG_GENERIC_HWEIGHT=y\n",
+"# CONFIG_STATIC_LINK is not set\n",
+"CONFIG_SELECT_MEMORY_MODEL=y\n",
+"CONFIG_FLATMEM_MANUAL=y\n",
+"CONFIG_FLATMEM=y\n",
+"CONFIG_FLAT_NODE_MEM_MAP=y\n",
+"CONFIG_PAGEFLAGS_EXTENDED=y\n",
+"CONFIG_SPLIT_PTLOCK_CPUS=4\n",
+"# CONFIG_PHYS_ADDR_T_64BIT is not set\n",
+"CONFIG_ZONE_DMA_FLAG=0\n",
+"CONFIG_VIRT_TO_BUS=y\n",
+"# CONFIG_KSM is not set\n",
+"CONFIG_DEFAULT_MMAP_MIN_ADDR=4096\n",
+"CONFIG_NEED_PER_CPU_KM=y\n",
+"CONFIG_TICK_ONESHOT=y\n",
+"CONFIG_NO_HZ=y\n",
+"CONFIG_HIGH_RES_TIMERS=y\n",
+"CONFIG_GENERIC_CLOCKEVENTS_BUILD=y\n",
+"CONFIG_LD_SCRIPT_DYN=y\n",
+"CONFIG_BINFMT_ELF=y\n",
+"CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y\n",
+"CONFIG_HAVE_AOUT=y\n",
+"# CONFIG_BINFMT_AOUT is not set\n",
+"CONFIG_BINFMT_MISC=m\n",
+"CONFIG_HOSTFS=y\n",
+"# CONFIG_HPPFS is not set\n",
+"CONFIG_MCONSOLE=y\n",
+"CONFIG_MAGIC_SYSRQ=y\n",
+"CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y\n",
+"# CONFIG_HIGHMEM is not set\n",
+"CONFIG_KERNEL_STACK_ORDER=0\n",
+"CONFIG_NO_DMA=y\n",
+"\n",
+"#\n",
+"# General setup\n",
+"#\n",
+"CONFIG_EXPERIMENTAL=y\n",
+"CONFIG_BROKEN_ON_SMP=y\n",
+"CONFIG_INIT_ENV_ARG_LIMIT=128\n",
+"CONFIG_CROSS_COMPILE=\"\"\n",
+"CONFIG_LOCALVERSION=\"\"\n",
+"CONFIG_LOCALVERSION_AUTO=y\n",
+"CONFIG_SWAP=y\n",
+"CONFIG_SYSVIPC=y\n",
+"CONFIG_SYSVIPC_SYSCTL=y\n",
+"CONFIG_POSIX_MQUEUE=y\n",
+"CONFIG_POSIX_MQUEUE_SYSCTL=y\n",
+"CONFIG_BSD_PROCESS_ACCT=y\n",
+"# CONFIG_BSD_PROCESS_ACCT_V3 is not set\n",
+"# CONFIG_TASKSTATS is not set\n",
+"# CONFIG_AUDIT is not set\n",
+"# CONFIG_HAVE_GENERIC_HARDIRQS is not set\n",
+"\n",
+"#\n",
+"# RCU Subsystem\n",
+"#\n",
+"CONFIG_TINY_RCU=y\n",
+"# CONFIG_PREEMPT_RCU is not set\n",
+"# CONFIG_TREE_RCU_TRACE is not set\n",
+"CONFIG_IKCONFIG=y\n",
+"CONFIG_IKCONFIG_PROC=y\n",
+"CONFIG_LOG_BUF_SHIFT=14\n",
+"# CONFIG_CGROUPS is not set\n",
+"CONFIG_NAMESPACES=y\n",
+"CONFIG_UTS_NS=y\n",
+"CONFIG_IPC_NS=y\n",
+"# CONFIG_USER_NS is not set\n",
+"# CONFIG_PID_NS is not set\n",
+"CONFIG_NET_NS=y\n",
+"CONFIG_SYSFS_DEPRECATED=y\n",
+"# CONFIG_SYSFS_DEPRECATED_V2 is not set\n",
+"# CONFIG_RELAY is not set\n",
+"# CONFIG_BLK_DEV_INITRD is not set\n",
+"CONFIG_CC_OPTIMIZE_FOR_SIZE=y\n",
+"CONFIG_SYSCTL=y\n",
+"CONFIG_ANON_INODES=y\n",
+"# CONFIG_EMBEDDED is not set\n",
+"CONFIG_UID16=y\n",
+"CONFIG_SYSCTL_SYSCALL=y\n",
+"CONFIG_KALLSYMS=y\n",
+"# CONFIG_KALLSYMS_ALL is not set\n",
+"CONFIG_KALLSYMS_EXTRA_PASS=y\n",
+"CONFIG_HOTPLUG=y\n",
+"CONFIG_PRINTK=y\n",
+"CONFIG_BUG=y\n",
+"CONFIG_ELF_CORE=y\n",
+"CONFIG_BASE_FULL=y\n",
+"CONFIG_FUTEX=y\n",
+"CONFIG_EPOLL=y\n",
+"CONFIG_SIGNALFD=y\n",
+"CONFIG_TIMERFD=y\n",
+"CONFIG_EVENTFD=y\n",
+"CONFIG_SHMEM=y\n",
+"CONFIG_AIO=y\n",
+"\n",
+"#\n",
+"# Kernel Performance Events And Counters\n",
+"#\n",
+"CONFIG_VM_EVENT_COUNTERS=y\n",
+"CONFIG_COMPAT_BRK=y\n",
+"CONFIG_SLAB=y\n",
+"# CONFIG_SLUB is not set\n",
+"# CONFIG_PROFILING is not set\n",
+"\n",
+"#\n",
+"# GCOV-based kernel profiling\n",
+"#\n",
+"# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set\n",
+"CONFIG_SLABINFO=y\n",
+"CONFIG_RT_MUTEXES=y\n",
+"CONFIG_BASE_SMALL=0\n",
+"CONFIG_MODULES=y\n",
+"# CONFIG_MODULE_FORCE_LOAD is not set\n",
+"CONFIG_MODULE_UNLOAD=y\n",
+"# CONFIG_MODULE_FORCE_UNLOAD is not set\n",
+"# CONFIG_MODVERSIONS is not set\n",
+"# CONFIG_MODULE_SRCVERSION_ALL is not set\n",
+"CONFIG_BLOCK=y\n",
+"CONFIG_LBDAF=y\n",
+"# CONFIG_BLK_DEV_BSG is not set\n",
+"# CONFIG_BLK_DEV_INTEGRITY is not set\n",
+"\n",
+"#\n",
+"# IO Schedulers\n",
+"#\n",
+"CONFIG_IOSCHED_NOOP=y\n",
+"CONFIG_IOSCHED_DEADLINE=y\n",
+"CONFIG_IOSCHED_CFQ=y\n",
+"# CONFIG_DEFAULT_DEADLINE is not set\n",
+"CONFIG_DEFAULT_CFQ=y\n",
+"# CONFIG_DEFAULT_NOOP is not set\n",
+"CONFIG_DEFAULT_IOSCHED=\"cfq\"\n",
+"# CONFIG_INLINE_SPIN_TRYLOCK is not set\n",
+"# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set\n",
+"# CONFIG_INLINE_SPIN_LOCK is not set\n",
+"# CONFIG_INLINE_SPIN_LOCK_BH is not set\n",
+"# CONFIG_INLINE_SPIN_LOCK_IRQ is not set\n",
+"# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set\n",
+"CONFIG_INLINE_SPIN_UNLOCK=y\n",
+"# CONFIG_INLINE_SPIN_UNLOCK_BH is not set\n",
+"CONFIG_INLINE_SPIN_UNLOCK_IRQ=y\n",
+"# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set\n",
+"# CONFIG_INLINE_READ_TRYLOCK is not set\n",
+"# CONFIG_INLINE_READ_LOCK is not set\n",
+"# CONFIG_INLINE_READ_LOCK_BH is not set\n",
+"# CONFIG_INLINE_READ_LOCK_IRQ is not set\n",
+"# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set\n",
+"CONFIG_INLINE_READ_UNLOCK=y\n",
+"# CONFIG_INLINE_READ_UNLOCK_BH is not set\n",
+"CONFIG_INLINE_READ_UNLOCK_IRQ=y\n",
+"# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set\n",
+"# CONFIG_INLINE_WRITE_TRYLOCK is not set\n",
+"# CONFIG_INLINE_WRITE_LOCK is not set\n",
+"# CONFIG_INLINE_WRITE_LOCK_BH is not set\n",
+"# CONFIG_INLINE_WRITE_LOCK_IRQ is not set\n",
+"# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set\n",
+"CONFIG_INLINE_WRITE_UNLOCK=y\n",
+"# CONFIG_INLINE_WRITE_UNLOCK_BH is not set\n",
+"CONFIG_INLINE_WRITE_UNLOCK_IRQ=y\n",
+"# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set\n",
+"# CONFIG_MUTEX_SPIN_ON_OWNER is not set\n",
+"# CONFIG_FREEZER is not set\n",
+"CONFIG_BLK_DEV=y\n",
+"CONFIG_BLK_DEV_UBD=y\n",
+"# CONFIG_BLK_DEV_UBD_SYNC is not set\n",
+"CONFIG_BLK_DEV_COW_COMMON=y\n",
+"CONFIG_BLK_DEV_LOOP=m\n",
+"# CONFIG_BLK_DEV_CRYPTOLOOP is not set\n",
+"\n",
+"#\n",
+"# DRBD disabled because PROC_FS, INET or CONNECTOR not selected\n",
+"#\n",
+"CONFIG_BLK_DEV_NBD=m\n",
+"# CONFIG_BLK_DEV_RAM is not set\n",
+"# CONFIG_ATA_OVER_ETH is not set\n",
+"# CONFIG_BLK_DEV_RBD is not set\n",
+"\n",
+"#\n",
+"# Character Devices\n",
+"#\n",
+"CONFIG_STDERR_CONSOLE=y\n",
+"CONFIG_STDIO_CONSOLE=y\n",
+"CONFIG_SSL=y\n",
+"CONFIG_NULL_CHAN=y\n",
+"CONFIG_PORT_CHAN=y\n",
+"CONFIG_PTY_CHAN=y\n",
+"CONFIG_TTY_CHAN=y\n",
+"CONFIG_XTERM_CHAN=y\n",
+"# CONFIG_NOCONFIG_CHAN is not set\n",
+"CONFIG_CON_ZERO_CHAN=\"fd:0,fd:1\"\n",
+"CONFIG_CON_CHAN=\"xterm\"\n",
+"CONFIG_SSL_CHAN=\"pts\"\n",
+"CONFIG_UNIX98_PTYS=y\n",
+"CONFIG_LEGACY_PTYS=y\n",
+"# CONFIG_RAW_DRIVER is not set\n",
+"CONFIG_LEGACY_PTY_COUNT=32\n",
+"# CONFIG_WATCHDOG is not set\n",
+"CONFIG_UML_SOUND=m\n",
+"CONFIG_SOUND=m\n",
+"CONFIG_SOUND_OSS_CORE=y\n",
+"CONFIG_HOSTAUDIO=m\n",
+"# CONFIG_HW_RANDOM is not set\n",
+"CONFIG_UML_RANDOM=y\n",
+"# CONFIG_MMAPPER is not set\n",
+"\n",
+"#\n",
+"# Generic Driver Options\n",
+"#\n",
+"CONFIG_UEVENT_HELPER_PATH=\"/sbin/hotplug\"\n",
+"# CONFIG_DEVTMPFS is not set\n",
+"CONFIG_STANDALONE=y\n",
+"CONFIG_PREVENT_FIRMWARE_BUILD=y\n",
+"CONFIG_FW_LOADER=y\n",
+"CONFIG_FIRMWARE_IN_KERNEL=y\n",
+"CONFIG_EXTRA_FIRMWARE=\"\"\n",
+"# CONFIG_DEBUG_DRIVER is not set\n",
+"# CONFIG_DEBUG_DEVRES is not set\n",
+"# CONFIG_SYS_HYPERVISOR is not set\n",
+"CONFIG_NET=y\n",
+"\n",
+"#\n",
+"# Networking options\n",
+"#\n",
+"CONFIG_PACKET=y\n",
+"CONFIG_UNIX=y\n",
+"CONFIG_XFRM=y\n",
+"# CONFIG_XFRM_USER is not set\n",
+"# CONFIG_XFRM_SUB_POLICY is not set\n",
+"# CONFIG_XFRM_MIGRATE is not set\n",
+"# CONFIG_XFRM_STATISTICS is not set\n",
+"# CONFIG_NET_KEY is not set\n",
+"CONFIG_INET=y\n",
+"# CONFIG_IP_MULTICAST is not set\n",
+"# CONFIG_IP_ADVANCED_ROUTER is not set\n",
+"CONFIG_IP_FIB_HASH=y\n",
+"# CONFIG_IP_PNP is not set\n",
+"# CONFIG_NET_IPIP is not set\n",
+"# CONFIG_NET_IPGRE_DEMUX is not set\n",
+"# CONFIG_ARPD is not set\n",
+"# CONFIG_SYN_COOKIES is not set\n",
+"# CONFIG_INET_AH is not set\n",
+"# CONFIG_INET_ESP is not set\n",
+"# CONFIG_INET_IPCOMP is not set\n",
+"# CONFIG_INET_XFRM_TUNNEL is not set\n",
+"# CONFIG_INET_TUNNEL is not set\n",
+"CONFIG_INET_XFRM_MODE_TRANSPORT=y\n",
+"CONFIG_INET_XFRM_MODE_TUNNEL=y\n",
+"CONFIG_INET_XFRM_MODE_BEET=y\n",
+"# CONFIG_INET_LRO is not set\n",
+"CONFIG_INET_DIAG=y\n",
+"CONFIG_INET_TCP_DIAG=y\n",
+"# CONFIG_TCP_CONG_ADVANCED is not set\n",
+"CONFIG_TCP_CONG_CUBIC=y\n",
+"CONFIG_DEFAULT_TCP_CONG=\"cubic\"\n",
+"# CONFIG_TCP_MD5SIG is not set\n",
+"# CONFIG_IPV6 is not set\n",
+"# CONFIG_NETWORK_SECMARK is not set\n",
+"# CONFIG_NETWORK_PHY_TIMESTAMPING is not set\n",
+"# CONFIG_NETFILTER is not set\n",
+"# CONFIG_IP_DCCP is not set\n",
+"# CONFIG_IP_SCTP is not set\n",
+"# CONFIG_RDS is not set\n",
+"# CONFIG_TIPC is not set\n",
+"# CONFIG_ATM is not set\n",
+"# CONFIG_L2TP is not set\n",
+"# CONFIG_BRIDGE is not set\n",
+"# CONFIG_NET_DSA is not set\n",
+"# CONFIG_VLAN_8021Q is not set\n",
+"# CONFIG_DECNET is not set\n",
+"# CONFIG_LLC2 is not set\n",
+"# CONFIG_IPX is not set\n",
+"# CONFIG_ATALK is not set\n",
+"# CONFIG_X25 is not set\n",
+"# CONFIG_LAPB is not set\n",
+"# CONFIG_ECONET is not set\n",
+"# CONFIG_WAN_ROUTER is not set\n",
+"# CONFIG_PHONET is not set\n",
+"# CONFIG_IEEE802154 is not set\n",
+"# CONFIG_NET_SCHED is not set\n",
+"# CONFIG_DCB is not set\n",
+"\n",
+"#\n",
+"# Network testing\n",
+"#\n",
+"# CONFIG_NET_PKTGEN is not set\n",
+"# CONFIG_HAMRADIO is not set\n",
+"# CONFIG_CAN is not set\n",
+"# CONFIG_IRDA is not set\n",
+"# CONFIG_BT is not set\n",
+"# CONFIG_AF_RXRPC is not set\n",
+"CONFIG_WIRELESS=y\n",
+"# CONFIG_CFG80211 is not set\n",
+"# CONFIG_LIB80211 is not set\n",
+"\n",
+"#\n",
+"# CFG80211 needs to be enabled for MAC80211\n",
+"#\n",
+"\n",
+"#\n",
+"# Some wireless drivers require a rate control algorithm\n",
+"#\n",
+"# CONFIG_WIMAX is not set\n",
+"# CONFIG_RFKILL is not set\n",
+"# CONFIG_NET_9P is not set\n",
+"# CONFIG_CAIF is not set\n",
+"# CONFIG_CEPH_LIB is not set\n",
+"\n",
+"#\n",
+"# UML Network Devices\n",
+"#\n",
+"CONFIG_UML_NET=y\n",
+"CONFIG_UML_NET_ETHERTAP=y\n",
+"CONFIG_UML_NET_TUNTAP=y\n",
+"CONFIG_UML_NET_SLIP=y\n",
+"CONFIG_UML_NET_DAEMON=y\n",
+"# CONFIG_UML_NET_VDE is not set\n",
+"CONFIG_UML_NET_MCAST=y\n",
+"# CONFIG_UML_NET_PCAP is not set\n",
+"CONFIG_UML_NET_SLIRP=y\n",
+"CONFIG_NETDEVICES=y\n",
+"CONFIG_DUMMY=m\n",
+"# CONFIG_BONDING is not set\n",
+"# CONFIG_MACVLAN is not set\n",
+"# CONFIG_EQUALIZER is not set\n",
+"CONFIG_TUN=m\n",
+"# CONFIG_VETH is not set\n",
+"# CONFIG_MII is not set\n",
+"# CONFIG_PHYLIB is not set\n",
+"CONFIG_WLAN=y\n",
+"# CONFIG_HOSTAP is not set\n",
+"\n",
+"#\n",
+"# Enable WiMAX (Networking options) to see the WiMAX drivers\n",
+"#\n",
+"# CONFIG_WAN is not set\n",
+"\n",
+"#\n",
+"# CAIF transport drivers\n",
+"#\n",
+"CONFIG_PPP=m\n",
+"# CONFIG_PPP_MULTILINK is not set\n",
+"# CONFIG_PPP_FILTER is not set\n",
+"# CONFIG_PPP_ASYNC is not set\n",
+"# CONFIG_PPP_SYNC_TTY is not set\n",
+"# CONFIG_PPP_DEFLATE is not set\n",
+"# CONFIG_PPP_BSDCOMP is not set\n",
+"# CONFIG_PPP_MPPE is not set\n",
+"# CONFIG_PPPOE is not set\n",
+"CONFIG_SLIP=m\n",
+"# CONFIG_SLIP_COMPRESSED is not set\n",
+"CONFIG_SLHC=m\n",
+"# CONFIG_SLIP_SMART is not set\n",
+"# CONFIG_SLIP_MODE_SLIP6 is not set\n",
+"# CONFIG_NETCONSOLE is not set\n",
+"# CONFIG_NETPOLL is not set\n",
+"# CONFIG_NET_POLL_CONTROLLER is not set\n",
+"# CONFIG_CONNECTOR is not set\n",
+"\n",
+"#\n",
+"# File systems\n",
+"#\n",
+"CONFIG_EXT2_FS=y\n",
+"# CONFIG_EXT2_FS_XATTR is not set\n",
+"# CONFIG_EXT2_FS_XIP is not set\n",
+"CONFIG_EXT3_FS=y\n",
+"CONFIG_EXT3_DEFAULTS_TO_ORDERED=y\n",
+"# CONFIG_EXT3_FS_XATTR is not set\n",
+"# CONFIG_EXT4_FS is not set\n",
+"CONFIG_JBD=y\n",
+"CONFIG_REISERFS_FS=y\n",
+"# CONFIG_REISERFS_CHECK is not set\n",
+"# CONFIG_REISERFS_PROC_INFO is not set\n",
+"# CONFIG_REISERFS_FS_XATTR is not set\n",
+"# CONFIG_JFS_FS is not set\n",
+"# CONFIG_FS_POSIX_ACL is not set\n",
+"# CONFIG_XFS_FS is not set\n",
+"# CONFIG_GFS2_FS is not set\n",
+"# CONFIG_OCFS2_FS is not set\n",
+"# CONFIG_BTRFS_FS is not set\n",
+"# CONFIG_NILFS2_FS is not set\n",
+"CONFIG_FILE_LOCKING=y\n",
+"CONFIG_FSNOTIFY=y\n",
+"CONFIG_DNOTIFY=y\n",
+"CONFIG_INOTIFY_USER=y\n",
+"# CONFIG_FANOTIFY is not set\n",
+"CONFIG_QUOTA=y\n",
+"# CONFIG_QUOTA_NETLINK_INTERFACE is not set\n",
+"CONFIG_PRINT_QUOTA_WARNING=y\n",
+"# CONFIG_QUOTA_DEBUG is not set\n",
+"# CONFIG_QFMT_V1 is not set\n",
+"# CONFIG_QFMT_V2 is not set\n",
+"CONFIG_QUOTACTL=y\n",
+"CONFIG_AUTOFS4_FS=m\n",
+"# CONFIG_FUSE_FS is not set\n",
+"\n",
+"#\n",
+"# Caches\n",
+"#\n",
+"# CONFIG_FSCACHE is not set\n",
+"\n",
+"#\n",
+"# CD-ROM/DVD Filesystems\n",
+"#\n",
+"CONFIG_ISO9660_FS=m\n",
+"CONFIG_JOLIET=y\n",
+"# CONFIG_ZISOFS is not set\n",
+"# CONFIG_UDF_FS is not set\n",
+"\n",
+"#\n",
+"# DOS/FAT/NT Filesystems\n",
+"#\n",
+"# CONFIG_MSDOS_FS is not set\n",
+"# CONFIG_VFAT_FS is not set\n",
+"# CONFIG_NTFS_FS is not set\n",
+"\n",
+"#\n",
+"# Pseudo filesystems\n",
+"#\n",
+"CONFIG_PROC_FS=y\n",
+"CONFIG_PROC_KCORE=y\n",
+"CONFIG_PROC_SYSCTL=y\n",
+"CONFIG_PROC_PAGE_MONITOR=y\n",
+"CONFIG_SYSFS=y\n",
+"CONFIG_TMPFS=y\n",
+"# CONFIG_TMPFS_POSIX_ACL is not set\n",
+"# CONFIG_HUGETLB_PAGE is not set\n",
+"# CONFIG_CONFIGFS_FS is not set\n",
+"CONFIG_MISC_FILESYSTEMS=y\n",
+"# CONFIG_ADFS_FS is not set\n",
+"# CONFIG_AFFS_FS is not set\n",
+"# CONFIG_HFS_FS is not set\n",
+"# CONFIG_HFSPLUS_FS is not set\n",
+"# CONFIG_BEFS_FS is not set\n",
+"# CONFIG_BFS_FS is not set\n",
+"# CONFIG_EFS_FS is not set\n",
+"# CONFIG_LOGFS is not set\n",
+"# CONFIG_CRAMFS is not set\n",
+"# CONFIG_SQUASHFS is not set\n",
+"# CONFIG_VXFS_FS is not set\n",
+"# CONFIG_MINIX_FS is not set\n",
+"# CONFIG_OMFS_FS is not set\n",
+"# CONFIG_HPFS_FS is not set\n",
+"# CONFIG_QNX4FS_FS is not set\n",
+"# CONFIG_ROMFS_FS is not set\n",
+"# CONFIG_SYSV_FS is not set\n",
+"# CONFIG_UFS_FS is not set\n",
+"CONFIG_NETWORK_FILESYSTEMS=y\n",
+"# CONFIG_NFS_FS is not set\n",
+"# CONFIG_NFSD is not set\n",
+"# CONFIG_CEPH_FS is not set\n",
+"# CONFIG_CIFS is not set\n",
+"# CONFIG_NCP_FS is not set\n",
+"# CONFIG_CODA_FS is not set\n",
+"# CONFIG_AFS_FS is not set\n",
+"\n",
+"#\n",
+"# Partition Types\n",
+"#\n",
+"# CONFIG_PARTITION_ADVANCED is not set\n",
+"CONFIG_MSDOS_PARTITION=y\n",
+"CONFIG_NLS=y\n",
+"CONFIG_NLS_DEFAULT=\"iso8859-1\"\n",
+"# CONFIG_NLS_CODEPAGE_437 is not set\n",
+"# CONFIG_NLS_CODEPAGE_737 is not set\n",
+"# CONFIG_NLS_CODEPAGE_775 is not set\n",
+"# CONFIG_NLS_CODEPAGE_850 is not set\n",
+"# CONFIG_NLS_CODEPAGE_852 is not set\n",
+"# CONFIG_NLS_CODEPAGE_855 is not set\n",
+"# CONFIG_NLS_CODEPAGE_857 is not set\n",
+"# CONFIG_NLS_CODEPAGE_860 is not set\n",
+"# CONFIG_NLS_CODEPAGE_861 is not set\n",
+"# CONFIG_NLS_CODEPAGE_862 is not set\n",
+"# CONFIG_NLS_CODEPAGE_863 is not set\n",
+"# CONFIG_NLS_CODEPAGE_864 is not set\n",
+"# CONFIG_NLS_CODEPAGE_865 is not set\n",
+"# CONFIG_NLS_CODEPAGE_866 is not set\n",
+"# CONFIG_NLS_CODEPAGE_869 is not set\n",
+"# CONFIG_NLS_CODEPAGE_936 is not set\n",
+"# CONFIG_NLS_CODEPAGE_950 is not set\n",
+"# CONFIG_NLS_CODEPAGE_932 is not set\n",
+"# CONFIG_NLS_CODEPAGE_949 is not set\n",
+"# CONFIG_NLS_CODEPAGE_874 is not set\n",
+"# CONFIG_NLS_ISO8859_8 is not set\n",
+"# CONFIG_NLS_CODEPAGE_1250 is not set\n",
+"# CONFIG_NLS_CODEPAGE_1251 is not set\n",
+"# CONFIG_NLS_ASCII is not set\n",
+"# CONFIG_NLS_ISO8859_1 is not set\n",
+"# CONFIG_NLS_ISO8859_2 is not set\n",
+"# CONFIG_NLS_ISO8859_3 is not set\n",
+"# CONFIG_NLS_ISO8859_4 is not set\n",
+"# CONFIG_NLS_ISO8859_5 is not set\n",
+"# CONFIG_NLS_ISO8859_6 is not set\n",
+"# CONFIG_NLS_ISO8859_7 is not set\n",
+"# CONFIG_NLS_ISO8859_9 is not set\n",
+"# CONFIG_NLS_ISO8859_13 is not set\n",
+"# CONFIG_NLS_ISO8859_14 is not set\n",
+"# CONFIG_NLS_ISO8859_15 is not set\n",
+"# CONFIG_NLS_KOI8_R is not set\n",
+"# CONFIG_NLS_KOI8_U is not set\n",
+"# CONFIG_NLS_UTF8 is not set\n",
+"# CONFIG_DLM is not set\n",
+"\n",
+"#\n",
+"# Security options\n",
+"#\n",
+"# CONFIG_KEYS is not set\n",
+"# CONFIG_SECURITY_DMESG_RESTRICT is not set\n",
+"# CONFIG_SECURITY is not set\n",
+"# CONFIG_SECURITYFS is not set\n",
+"CONFIG_DEFAULT_SECURITY_DAC=y\n",
+"CONFIG_DEFAULT_SECURITY=\"\"\n",
+"CONFIG_CRYPTO=y\n",
+"\n",
+"#\n",
+"# Crypto core or helper\n",
+"#\n",
+"# CONFIG_CRYPTO_FIPS is not set\n",
+"CONFIG_CRYPTO_ALGAPI=m\n",
+"CONFIG_CRYPTO_ALGAPI2=m\n",
+"CONFIG_CRYPTO_RNG=m\n",
+"CONFIG_CRYPTO_RNG2=m\n",
+"# CONFIG_CRYPTO_MANAGER is not set\n",
+"# CONFIG_CRYPTO_MANAGER2 is not set\n",
+"# CONFIG_CRYPTO_GF128MUL is not set\n",
+"# CONFIG_CRYPTO_NULL is not set\n",
+"# CONFIG_CRYPTO_CRYPTD is not set\n",
+"# CONFIG_CRYPTO_AUTHENC is not set\n",
+"# CONFIG_CRYPTO_TEST is not set\n",
+"\n",
+"#\n",
+"# Authenticated Encryption with Associated Data\n",
+"#\n",
+"# CONFIG_CRYPTO_CCM is not set\n",
+"# CONFIG_CRYPTO_GCM is not set\n",
+"# CONFIG_CRYPTO_SEQIV is not set\n",
+"\n",
+"#\n",
+"# Block modes\n",
+"#\n",
+"# CONFIG_CRYPTO_CBC is not set\n",
+"# CONFIG_CRYPTO_CTR is not set\n",
+"# CONFIG_CRYPTO_CTS is not set\n",
+"# CONFIG_CRYPTO_ECB is not set\n",
+"# CONFIG_CRYPTO_LRW is not set\n",
+"# CONFIG_CRYPTO_PCBC is not set\n",
+"# CONFIG_CRYPTO_XTS is not set\n",
+"\n",
+"#\n",
+"# Hash modes\n",
+"#\n",
+"# CONFIG_CRYPTO_HMAC is not set\n",
+"# CONFIG_CRYPTO_XCBC is not set\n",
+"# CONFIG_CRYPTO_VMAC is not set\n",
+"\n",
+"#\n",
+"# Digest\n",
+"#\n",
+"# CONFIG_CRYPTO_CRC32C is not set\n",
+"# CONFIG_CRYPTO_GHASH is not set\n",
+"# CONFIG_CRYPTO_MD4 is not set\n",
+"# CONFIG_CRYPTO_MD5 is not set\n",
+"# CONFIG_CRYPTO_MICHAEL_MIC is not set\n",
+"# CONFIG_CRYPTO_RMD128 is not set\n",
+"# CONFIG_CRYPTO_RMD160 is not set\n",
+"# CONFIG_CRYPTO_RMD256 is not set\n",
+"# CONFIG_CRYPTO_RMD320 is not set\n",
+"# CONFIG_CRYPTO_SHA1 is not set\n",
+"# CONFIG_CRYPTO_SHA256 is not set\n",
+"# CONFIG_CRYPTO_SHA512 is not set\n",
+"# CONFIG_CRYPTO_TGR192 is not set\n",
+"# CONFIG_CRYPTO_WP512 is not set\n",
+"\n",
+"#\n",
+"# Ciphers\n",
+"#\n",
+"CONFIG_CRYPTO_AES=m\n",
+"# CONFIG_CRYPTO_AES_586 is not set\n",
+"# CONFIG_CRYPTO_ANUBIS is not set\n",
+"# CONFIG_CRYPTO_ARC4 is not set\n",
+"# CONFIG_CRYPTO_BLOWFISH is not set\n",
+"# CONFIG_CRYPTO_CAMELLIA is not set\n",
+"# CONFIG_CRYPTO_CAST5 is not set\n",
+"# CONFIG_CRYPTO_CAST6 is not set\n",
+"# CONFIG_CRYPTO_DES is not set\n",
+"# CONFIG_CRYPTO_FCRYPT is not set\n",
+"# CONFIG_CRYPTO_KHAZAD is not set\n",
+"# CONFIG_CRYPTO_SALSA20 is not set\n",
+"# CONFIG_CRYPTO_SALSA20_586 is not set\n",
+"# CONFIG_CRYPTO_SEED is not set\n",
+"# CONFIG_CRYPTO_SERPENT is not set\n",
+"# CONFIG_CRYPTO_TEA is not set\n",
+"# CONFIG_CRYPTO_TWOFISH is not set\n",
+"# CONFIG_CRYPTO_TWOFISH_586 is not set\n",
+"\n",
+"#\n",
+"# Compression\n",
+"#\n",
+"# CONFIG_CRYPTO_DEFLATE is not set\n",
+"# CONFIG_CRYPTO_ZLIB is not set\n",
+"# CONFIG_CRYPTO_LZO is not set\n",
+"\n",
+"#\n",
+"# Random Number Generation\n",
+"#\n",
+"CONFIG_CRYPTO_ANSI_CPRNG=m\n",
+"CONFIG_CRYPTO_HW=y\n",
+"# CONFIG_BINARY_PRINTF is not set\n",
+"\n",
+"#\n",
+"# Library routines\n",
+"#\n",
+"CONFIG_BITREVERSE=y\n",
+"CONFIG_GENERIC_FIND_FIRST_BIT=y\n",
+"CONFIG_GENERIC_FIND_NEXT_BIT=y\n",
+"CONFIG_GENERIC_FIND_LAST_BIT=y\n",
+"# CONFIG_CRC_CCITT is not set\n",
+"# CONFIG_CRC16 is not set\n",
+"# CONFIG_CRC_T10DIF is not set\n",
+"# CONFIG_CRC_ITU_T is not set\n",
+"CONFIG_CRC32=y\n",
+"# CONFIG_CRC7 is not set\n",
+"# CONFIG_LIBCRC32C is not set\n",
+"CONFIG_NLATTR=y\n",
+"\n",
+"#\n",
+"# SCSI device support\n",
+"#\n",
+"CONFIG_SCSI_MOD=y\n",
+"# CONFIG_RAID_ATTRS is not set\n",
+"# CONFIG_SCSI is not set\n",
+"# CONFIG_SCSI_DMA is not set\n",
+"# CONFIG_SCSI_NETLINK is not set\n",
+"# CONFIG_MD is not set\n",
+"# CONFIG_NEW_LEDS is not set\n",
+"# CONFIG_INPUT is not set\n",
+"\n",
+"#\n",
+"# Kernel hacking\n",
+"#\n",
+"# CONFIG_PRINTK_TIME is not set\n",
+"CONFIG_ENABLE_WARN_DEPRECATED=y\n",
+"CONFIG_ENABLE_MUST_CHECK=y\n",
+"CONFIG_FRAME_WARN=1024\n",
+"# CONFIG_STRIP_ASM_SYMS is not set\n",
+"# CONFIG_UNUSED_SYMBOLS is not set\n",
+"# CONFIG_DEBUG_FS is not set\n",
+"CONFIG_DEBUG_KERNEL=y\n",
+"# CONFIG_DEBUG_SHIRQ is not set\n",
+"# CONFIG_LOCKUP_DETECTOR is not set\n",
+"# CONFIG_HARDLOCKUP_DETECTOR is not set\n",
+"# CONFIG_DETECT_HUNG_TASK is not set\n",
+"CONFIG_SCHED_DEBUG=y\n",
+"# CONFIG_SCHEDSTATS is not set\n",
+"# CONFIG_TIMER_STATS is not set\n",
+"# CONFIG_DEBUG_OBJECTS is not set\n",
+"# CONFIG_DEBUG_SLAB is not set\n",
+"# CONFIG_DEBUG_RT_MUTEXES is not set\n",
+"# CONFIG_RT_MUTEX_TESTER is not set\n",
+"# CONFIG_DEBUG_SPINLOCK is not set\n",
+"# CONFIG_DEBUG_MUTEXES is not set\n",
+"CONFIG_BKL=y\n",
+"# CONFIG_SPARSE_RCU_POINTER is not set\n",
+"# CONFIG_DEBUG_SPINLOCK_SLEEP is not set\n",
+"# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set\n",
+"# CONFIG_DEBUG_KOBJECT is not set\n",
+"CONFIG_DEBUG_BUGVERBOSE=y\n",
+"CONFIG_DEBUG_INFO=y\n",
+"# CONFIG_DEBUG_INFO_REDUCED is not set\n",
+"# CONFIG_DEBUG_VM is not set\n",
+"# CONFIG_DEBUG_WRITECOUNT is not set\n",
+"CONFIG_DEBUG_MEMORY_INIT=y\n",
+"# CONFIG_DEBUG_LIST is not set\n",
+"# CONFIG_TEST_LIST_SORT is not set\n",
+"# CONFIG_DEBUG_SG is not set\n",
+"# CONFIG_DEBUG_NOTIFIERS is not set\n",
+"# CONFIG_DEBUG_CREDENTIALS is not set\n",
+"CONFIG_FRAME_POINTER=y\n",
+"# CONFIG_BOOT_PRINTK_DELAY is not set\n",
+"# CONFIG_RCU_TORTURE_TEST is not set\n",
+"# CONFIG_BACKTRACE_SELF_TEST is not set\n",
+"# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set\n",
+"# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set\n",
+"# CONFIG_FAULT_INJECTION is not set\n",
+"# CONFIG_SYSCTL_SYSCALL_CHECK is not set\n",
+"# CONFIG_PAGE_POISONING is not set\n",
+"# CONFIG_ATOMIC64_SELFTEST is not set\n",
+"# CONFIG_SAMPLES is not set\n",
+"# CONFIG_GPROF is not set\n",
+"# CONFIG_GCOV is not set\n",
+"# CONFIG_DEBUG_STACK_USAGE is not set\n",
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/arch/x86/include/asm/unistd_32.h linux-2.6.37.4/arch/x86/include/asm/unistd_32.h
--- linux-2.6.37.4-orig/arch/x86/include/asm/unistd_32.h	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/arch/x86/include/asm/unistd_32.h	2012-06-21 22:30:05.000000000 +0300
@@ -346,10 +346,11 @@
 #define __NR_fanotify_init	338
 #define __NR_fanotify_mark	339
 #define __NR_prlimit64		340
+#define __NR_curse			341
 
 #ifdef __KERNEL__
 
-#define NR_syscalls 341
+#define NR_syscalls 342
 
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/arch/x86/include/asm/unistd_64.h linux-2.6.37.4/arch/x86/include/asm/unistd_64.h
--- linux-2.6.37.4-orig/arch/x86/include/asm/unistd_64.h	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/arch/x86/include/asm/unistd_64.h	2012-06-21 22:30:05.000000000 +0300
@@ -669,6 +669,8 @@ __SYSCALL(__NR_fanotify_init, sys_fanoti
 __SYSCALL(__NR_fanotify_mark, sys_fanotify_mark)
 #define __NR_prlimit64				302
 __SYSCALL(__NR_prlimit64, sys_prlimit64)
+#define __NR_curse					303
+__SYSCALL(__NR_curse, sys_curse)
 
 #ifndef __NO_STUBS
 #define __ARCH_WANT_OLD_READDIR
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/arch/x86/Kconfig linux-2.6.37.4/arch/x86/Kconfig
--- linux-2.6.37.4-orig/arch/x86/Kconfig	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/arch/x86/Kconfig	2012-06-21 22:30:05.000000000 +0300
@@ -2127,3 +2127,5 @@ source "crypto/Kconfig"
 source "arch/x86/kvm/Kconfig"
 
 source "lib/Kconfig"
+
+source "curse_imp/Kconfig"
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/arch/x86/kernel/syscall_table_32.S linux-2.6.37.4/arch/x86/kernel/syscall_table_32.S
--- linux-2.6.37.4-orig/arch/x86/kernel/syscall_table_32.S	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/arch/x86/kernel/syscall_table_32.S	2012-06-21 22:30:05.000000000 +0300
@@ -340,3 +340,4 @@ ENTRY(sys_call_table)
 	.long sys_fanotify_init
 	.long sys_fanotify_mark
 	.long sys_prlimit64		/* 340 */
+	.long sys_curse
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/COMMANDS linux-2.6.37.4/curse_imp/COMMANDS
--- linux-2.6.37.4-orig/curse_imp/COMMANDS	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/COMMANDS	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,66 @@
+======================================COMMANDS======================================
+1. LIST_ALL								:	<no_argument>
+Lists all curses in the curse list, implemented and not.
+	R: <?>
+//IMPORTANT: Depending on the way we do the copy to userspace, this should not even matter. I think it would be better if we went with the proc filesystem mapping solution (it is not a case where the data is time sensitive).
+2. ACTIVATE								:	id of curse to activate
+Activates the curse with the provided id, or activates the curse system if id is 0.
+	R: 1 on success - appropriate code on failure
+3. DEACTIVATE							:	id of curse to deactivate
+Deactivates the curse with the provided id or the whole system (disables the curse mechanism) if it is 0.
+	R: <same>
+4. CHECK_CURSE_ACTIVITY					:	id of curse to check
+Checks if a curse is active (false if the curse mechanism is deactivated).
+	R: 1 if a curse is active - 0 if no curse is active - appropriate code on error
+5. CHECK_TAINTED_PROCESS				:	pid_t of the process to check (-1 to check for any process (?TODO)), id of curse to check
+Check if the requested process has an active curse	(false if the user has not permissions to that process).
+	R: <same>
+6. CAST (ex deploy (ex unleash))		:	pid_t of the process to target, id of the curse to use
+Set a curse upon a target.
+	R: 1 on success - appropriate code on failure
+7. LIFT (ex retire)						:	<same>
+Remove a curse from a target.
+	R: <same>
+8. CTRL									:	id of curse to modify, control operation to perform
+Control the behavior of a curse. This can affect the inheritance attribute of a curse (previously affected objects are not affected), or the permissions of that curse (process-specific)
+	R: <same>
+9. GET_CURSE_NO							:	<nothing>
+Get the number of the existent curses on the system
+	R: Number of implemented curses.
+------RULES: Rules are static bindings of curses to binaries (paths) instead of processes.------ :: These are supplementary. We may implement them, after the main implementation of the system call.
+8. SHOW_RULES							:	<no_argument>
+Show all rules that are currently in the system.
+	R: <?>
+9. ADD_RULES							:	identifier to the binary (TODO: path/inode(?)), id of the curse to deploy
+Add a new rule (this adds a binding, and deploys the rule).
+	R: 1 on success - appropriate code on failure
+10.REM_RULE								:	<same>
+Remove an existing rule.
+	R: 1 on success - appropriate code on failure
+
+=======================================STATUS=======================================
+IMPLEMENTED		0x00
+Curse has code (vs. placeholders).
+ACTIVATED		0x01
+Curse can become active. (is implemented, not active)
+CASTED			0x02
+Currently running (influencing the system). (is implemented, and activated)
+INVALID_CURSE	0x04
+Not valid. (not implemented)
+
+=====================================ATTRIBUTES=====================================
+1. Inheritance		:	defaults to true.
+	A curse has an inheritance attribute that controls whether children of an infected process (spawned after the parent was infected) will be infected themselves.
+2. Permissions		:	defaults to full permissions for user and super user.
+	Permissions consist of active and passive. Active are indicative of the ability to cast curses, while passive indicate the ability to have a curse casted on the process.
+	A curse has 4 characteristic permissions that influence the permission checking during limited access operations. These attributes are process specific, meaning that 2 different processes can have different permission values.
+		User Permission:		Control whether the user will have permission to perform controlled operations with the curse system call.
+		Group Permission:		Same, applying to the effective user group (unused).
+		Super User Permission:	Same, applicable in case of super user.
+
+=================================CONTROL_OPERATIONS=================================
+SET_INH									:	Sets the inheritance attribute to true for the specified curse.
+CLR_INH									:	<the opposite>
+{USR, SU}_{ACTIVE, PASSIVE}_PERM_ON		:	Sets the active and passive permissions for the current curse for user and super user respectively.
+{USR, SU}_{ACTIVE, PASSIVE}_PERM_OFF	:	<the opposite>
+
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/curse.c linux-2.6.37.4/curse_imp/curse.c
--- linux-2.6.37.4-orig/curse_imp/curse.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/curse.c	2012-06-24 15:14:35.000000000 +0300
@@ -0,0 +1,540 @@
+/*
+ * This file contains the source code for the curse system call.
+ *
+ * [The functions used by the system call are sourced below it.]
+ *
+ */
+#include <linux/syscalls.h>
+#ifdef CONFIG_CURSES
+
+#include <linux/types.h>		/*Sentinels prevent multiple inclusion.*/
+#include <linux/spinlock.h>
+#include <linux/rcupdate.h>
+#include <linux/namei.h>
+
+#include <curse/curse.h>
+#include <curse/curse_types.h>
+
+#define CURSE_SYSTEM 0
+#define CURSE_TARGETED 1
+#define CURSE_REMOTE 2
+
+//=====External declarations.
+extern int max_curse_no;
+extern struct curse_list_entry *curse_full_list;
+
+//=====Various wrapper functions.
+/*This function returns the bitmask for the specified normalized curse index.*/
+inline uint64_t bitmask_from_no (int  a_c_id)
+{
+	return curse_list_pointer[a_c_id].curse_bit;
+}
+
+/*This macro expands to the requested field of the requested element of curse_list_pointer array.*/
+#define CURSE_FIELD(el, field) (curse_list_pointer[(el)].field)
+
+/*This function checks if current is allowed to change the state of the target proc.*/
+static int check_permissions (pid_t target, int type)
+{
+	struct task_struct *foreign_task;
+	const struct cred *foreign_c = NULL, *local_c = NULL;
+	uint8_t local_curse_perms;
+	uint8_t foreign_curse_perms;
+	int ret = -EINVAL;
+	unsigned long spinflags;
+
+	spin_lock_irqsave(&((current->curse_data).protection), spinflags);
+	local_curse_perms = current->curse_data.permissions;
+	spin_unlock_irqrestore(&((current->curse_data).protection), spinflags);
+	local_c = get_current_cred();
+
+	switch(type) {
+		case CURSE_SYSTEM:
+			ret = -EPERM;
+			if ((local_c->euid == 0) && (local_curse_perms & _SU_ACTIVE_PERM))
+				ret = 1;
+			goto out_with_local;
+		case CURSE_REMOTE:
+		case CURSE_TARGETED:
+			ret = -ESRCH;		//FIXME: Sanity check.
+			rcu_read_lock();
+			foreign_task = find_task_by_vpid(target);
+			rcu_read_unlock();
+			if (!foreign_task)
+				goto out;
+
+			ret = -EINVAL;		//FIXME: Sanity check.
+			foreign_c = get_task_cred(foreign_task);
+
+			if (!foreign_c)
+				goto out_with_local;
+			/* am i root or sudo?? */
+			/* do we belong to the same effective user?*/
+
+			spin_lock_irqsave(&((foreign_task->curse_data).protection), spinflags);
+			foreign_curse_perms = foreign_task->curse_data.permissions;
+			spin_unlock_irqrestore(&((foreign_task->curse_data).protection), spinflags);
+
+			ret = -EPERM;
+			if (type == CURSE_TARGETED) {
+				if (((local_c->euid == 0) && (local_curse_perms & _SU_ACTIVE_PERM) && (foreign_curse_perms & _SU_PASSIVE_PERM))	||	\
+						(((local_c->euid == foreign_c->euid) || (local_c->euid == foreign_c->uid))								&&	\
+						 (local_curse_perms & _USR_ACTIVE_PERM) && (foreign_curse_perms & _USR_PASSIVE_PERM)))
+					ret = 1;
+			} else {
+				if ((local_c->euid == 0) || (local_c->euid == foreign_c->euid) || (local_c->euid == foreign_c->uid))
+					ret = 1;
+			}
+
+	}
+	put_cred(foreign_c);
+out_with_local:
+	put_cred(local_c);
+out:
+	return ret;
+}
+
+/*This function takes a userspace string, and returns: 0 with the inode number in inode_number, or error.*/
+static int inode_from_user_path (char __user *path, unsigned long *inode_number)
+{
+	int ret = -ENOMEM;
+	char *kernel_buffer;
+	ssize_t len = (sizeof(path)+1);
+	struct path tmp;
+	umode_t in_mode;
+
+	debug("Length is %d.\n", (int)len);
+	if ((kernel_buffer = kzalloc(sizeof(char)*len, GFP_KERNEL)) == NULL)
+		goto out;
+	ret = -EFAULT;
+	if (copy_from_user(kernel_buffer, path, len))
+		goto out;
+	debug("String is %s.\n", kernel_buffer);
+
+	if ((ret = kern_path(/*transformed path*/ kernel_buffer, /*flags*/ LOOKUP_FOLLOW, &tmp)))
+		goto out;
+	debug("kern_path return is %d.\n", ret);
+
+	(*inode_number) = tmp.dentry->d_inode->i_ino;
+	in_mode = tmp.dentry->d_inode->i_mode;
+
+	debug("inode number is %lu and mode is %d\n", (*inode_number), (int)in_mode);
+	if (!(in_mode & S_IXUGO)) {
+		ret = -EPERM;
+		debug("not executable\n");
+	}
+
+	path_put(&tmp);
+
+out:
+	return ret;
+}
+
+//=====Source syscall sub-functions.
+static int syscurse_list_all (char __user *buf)
+{
+	int ret = -EINVAL;
+	size_t length;
+	//FIXME: I will add them for support, even if they are unused.
+/*
+	static size_t offset=0;
+
+	if (len <= 0)
+		goto out;
+*/
+	//length = sizeof(curse_full_list);
+	length = sizeof(struct curse_list_entry)*max_curse_no;
+//	ret = ((length - offset) >= len) ? len : (length - offset);
+
+	ret = 1;
+//	debug("My master you ask me to copy %u bytes, i shall do my best...\n", (unsigned int) length);
+	if (copy_to_user(buf, (const char *)&curse_full_list/*+offset*/, length)) {
+		ret=-EFAULT;
+		goto out;
+	}
+/*
+	offset += ret;
+	if (offset == length)
+		offset=0;
+*/
+out:
+	return ret;
+}
+
+static int syscurse_activate (int curse_no)
+{
+	int i, ret = -EPERM;
+
+	i = curse_no;
+	if ((ret = check_permissions(0, CURSE_SYSTEM)) != 1)
+		goto out_ret;
+
+	ret = 1;
+	//Found a use for stub curse 0: activates the general curse system without activating any curse.
+	if (bitmask_from_no(curse_no)) {								//Activation of an existing curse, activates the system too.
+		if (!(CURSE_FIELD(i, status) & ACTIVATED)) {
+			CURSE_FIELD(i, status) |= ACTIVATED;
+		} else {
+			ret = -EINVAL;
+			goto out_ret;
+		}
+	}
+	if (!CURSE_SYSTEM_Q)											//On invalid id, system activation.
+		CURSE_SYSTEM_UP;
+
+out_ret:
+	return ret;
+}
+
+static int syscurse_deactivate (int curse_no)
+{
+	int i, ret = -EPERM;
+
+	if ((ret = check_permissions(0, CURSE_SYSTEM)) != 1)
+		goto out_ret;
+	i = curse_no;
+
+	ret = 1;
+	if (bitmask_from_no(curse_no)) {								//Targeted deactivation is normal.
+		if (CURSE_FIELD(i, status) & ACTIVATED) {
+			CURSE_FIELD(i, status) &= ~ACTIVATED;
+		} else {
+			ret = -EINVAL;
+			goto out_ret;
+		}
+	} else if (/*!bitmask_from_no(curse_no) && */ CURSE_SYSTEM_Q)	//Invalid target deactivates the system.
+		CURSE_SYSTEM_DOWN;
+
+	//TODO: Do we have to unhook (call close pointer) all the active curses here?	::	No, we simply deactivate. On activation, it will continue as was.
+
+out_ret:
+	return ret;
+}
+
+static int syscurse_check_curse_activity (int curse_no)
+{
+	int i, ret = -EINTR;
+
+	if (!CURSE_SYSTEM_Q)
+		goto out;
+
+	i = curse_no;
+	if (CURSE_FIELD(i, entry)->curse_id == 0xABADDE5C) {
+		ret = -EINVAL;
+		goto out;
+	}
+	if (CURSE_FIELD(i, status) & CASTED)
+		ret = 1;
+	else
+		ret = 0;
+
+out:
+	return ret;
+}
+
+static int syscurse_check_tainted_process (int curse_no, pid_t target)
+{
+	int err = -EINVAL;
+	uint64_t check_bit;
+	unsigned long spinflags;
+	struct task_struct *target_task;
+
+	if (!(check_bit = bitmask_from_no(curse_no)) || (target <= 0))
+		goto out;
+	if (!CURSE_SYSTEM_Q)
+		goto out;
+
+	err = -ESRCH;
+	rcu_read_lock();
+	target_task = find_task_by_vpid(target);
+	rcu_read_unlock();
+	if (!target_task)
+		goto out;
+
+	err = -EINVAL;
+	if (target <= 0)
+		goto out;
+	if ((err = check_permissions(target, CURSE_TARGETED)) != 1)
+		goto out;
+	err = 0;
+
+	//Check if target has an active curse on it.	::	FIXME: Move it to one-liner? Is it better?
+	spin_lock_irqsave(&((target_task->curse_data).protection), spinflags);
+	if (target_task->curse_data.curse_field & check_bit)
+		err = 1;
+	else
+		err = 0;
+	spin_unlock_irqrestore(&((target_task->curse_data).protection), spinflags);
+
+out:
+	return err;
+}
+
+static int syscurse_ctrl (int curse_no, int ctrl, pid_t pid)
+{
+	int index, ret = -EINVAL;
+	struct task_struct *target_task;
+	struct task_curse_struct *cur_curse_field;
+	unsigned long flags = 0;
+	uint8_t ctrl_masks[] = {_USR_ACTIVE_PERM, _USR_PASSIVE_PERM, _SU_ACTIVE_PERM, _SU_PASSIVE_PERM};
+	_Bool set_clr;
+	int com_index;
+
+	index = curse_no;
+
+	spin_lock_irqsave(&CURSE_FIELD(index, flag_lock), flags);
+	ret = 1;
+	switch (ctrl) {		/*Inherritance (on curse_list_pointer array)*/
+	case INH_ON		:
+		SET_INHER(index);
+		break;
+	case INH_OFF	:
+		CLR_INHER(index);
+		break;
+	default:
+		ret = -1;
+	}
+	spin_unlock_irqrestore(&CURSE_FIELD(index, flag_lock), flags);
+
+	if (ret == 1)
+		goto out;
+
+	rcu_read_lock();
+	target_task = find_task_by_vpid(pid);
+	rcu_read_unlock();
+	if (!target_task)
+		goto out;
+	cur_curse_field = &(target_task->curse_data);
+
+	ret = -EINVAL;
+	if (pid <= 0)
+		goto out;
+	if ((ret = check_permissions(pid, CURSE_REMOTE)) != 1) {
+		goto out;
+	}
+
+	if ((ctrl >= USR_ACTIVE_PERM_ON) && (ctrl <= SU_PASSIVE_PERM_ON)) {
+		set_clr=0;
+		com_index = (ctrl - USR_ACTIVE_PERM_ON);
+	} else if ((ctrl >= USR_ACTIVE_PERM_OFF) && (ctrl <= SU_PASSIVE_PERM_OFF)) {
+		set_clr=1;
+		com_index = (ctrl - USR_ACTIVE_PERM_OFF);
+	} else {
+		set_clr=2;
+	}
+
+	spin_lock_irqsave(&(cur_curse_field->protection), flags);
+	switch (set_clr) {		/*Permissions (on task_curse_struct struct)*/
+		case 0	:
+			SET_PERM((*cur_curse_field), ctrl_masks[com_index]);
+			break;
+		case 1	:
+			CLR_PERM((*cur_curse_field), ctrl_masks[com_index]);
+			break;
+		default	:
+			ret = -EINVAL;
+	}
+	spin_unlock_irqrestore(&(cur_curse_field->protection), flags);
+
+out:
+	return ret;
+}
+
+static int syscurse_cast (int curse_no, pid_t target)
+{
+	int err = -EINVAL;
+	unsigned long spinflags;
+	struct task_struct *target_task;
+	int new_index;
+	uint64_t new_mask;
+
+	if (!CURSE_SYSTEM_Q)
+		goto out;
+
+
+	err = -ESRCH;
+	rcu_read_lock();
+	target_task = find_task_by_vpid(target);
+	rcu_read_unlock();
+	if (!target_task)
+		goto out;
+
+	err = -EINVAL;
+	if (target <= 0 )
+		goto out;
+	if ((err = check_permissions(target, CURSE_TARGETED)) != 1)
+		goto out;
+
+	err = -EINVAL;
+	new_index = curse_no;
+	new_mask = CURSE_FIELD(new_index, curse_bit);
+
+	if ((!new_mask) || (!(CURSE_FIELD(new_index, status) & ACTIVATED)))
+		goto out;
+
+	spin_lock_irqsave(&((target_task->curse_data).protection), spinflags);
+	if (!(target_task->curse_data.curse_field & new_mask)) {
+		target_task->curse_data.curse_field |= new_mask;
+		atomic_inc(&CURSE_FIELD(new_index, ref_count));
+		if (GET_INHER(new_index))
+			target_task->curse_data.inherritance |= new_mask;
+		else
+			target_task->curse_data.inherritance &= (~new_mask);
+		CURSE_FIELD(new_index, status) |= CASTED;
+		err = 1;
+	}
+	spin_unlock_irqrestore(&((target_task->curse_data).protection), spinflags);
+	CURSE_FIELD(new_index, functions)->fun_init(target_task);	//Call init after cast.
+
+out:
+	return err;
+}
+
+static int syscurse_lift (int curse_no, pid_t target)
+{
+	int err = -EINVAL;
+	unsigned long spinflags;
+	struct task_struct *target_task;
+	uint64_t curse_mask;
+	int index;
+
+	if (!CURSE_SYSTEM_Q)
+		goto out;
+
+	index = curse_no;
+	err = -ESRCH;
+	rcu_read_lock();
+	target_task = find_task_by_vpid(target);
+	rcu_read_unlock();
+	if (!target_task)
+		goto out;
+
+	err = -EINVAL;
+	if (target <= 0)
+		goto out;
+	if ((err = check_permissions(target, CURSE_TARGETED)) != 1)
+		goto out;
+
+	err = -EINVAL;
+	if (!(curse_mask = CURSE_FIELD(index, curse_bit)))
+		goto out;
+
+	spin_lock_irqsave(&((target_task->curse_data).protection), spinflags);
+	if (target_task->curse_data.curse_field & curse_mask) {
+		target_task->curse_data.curse_field &= (~curse_mask);		//Just to be safe (^= toggles, not clears).
+		atomic_dec(&CURSE_FIELD(index, ref_count));
+		target_task->curse_data.inherritance &= (~curse_mask);
+		if (atomic_read(&CURSE_FIELD(index, ref_count)) == 0)		//Revert curse status to ACTIVATED if ref 0ed-out.	: Could be atomic_dec_and_set.
+			CURSE_FIELD(index, status) &= ~CASTED;
+		err = 1;
+	}
+	spin_unlock_irqrestore(&((target_task->curse_data).protection), spinflags);
+
+	CURSE_FIELD(index, functions)->fun_destroy(target_task);	//Call destroy after lift.
+
+out:
+	return err;
+}
+
+static int syscurse_show_rules (void)
+{
+	return 0;
+}
+
+static int syscurse_add_rule (int curse, char __user *path)
+{
+	int ret = -EINVAL;
+	unsigned long in_num;
+
+	//Find inode
+	//Check if executable
+	if ((ret = inode_from_user_path(path, &in_num)))
+		goto out;
+
+	//Check permissions
+	//Check if it is already in saved
+	//Else do it
+
+out:
+	return ret;
+}
+
+static int syscurse_rem_rule (int curse, char *path)
+{
+	//Find inode
+	//Check if it is in saved
+	//Check permissions
+	//Else do it
+	return 0;
+}
+
+//=====Syscall kernel source.
+/*This is the system call source base function.*/
+SYSCALL_DEFINE5 (curse, unsigned int, curse_cmd, int, curse_no, pid_t, target, int, cur_ctrl, char __user *, buf)		//asmlinkage long sys_curse(int curse_cmd, int curse_no, pid_t target)
+{
+	long ret = -EINVAL;
+	int cmd_norm = (int) curse_cmd;
+	if ((curse_no < 0) || (curse_no >=max_curse_no))
+		goto out;
+
+//	debug("Master, you gave me command %d with curse %d on pid %ld.\n", curse_cmd, curse_no, (long)target);
+
+	//Do not even call if curse system is not active.
+	switch (cmd_norm) {
+	case LIST_ALL:
+		ret = syscurse_list_all(buf);
+		break;
+	case CURSE_CTRL:
+		ret = syscurse_ctrl(curse_no, cur_ctrl, target);
+		break;
+	case ACTIVATE:
+		ret = syscurse_activate(curse_no);
+		break;
+	case DEACTIVATE:
+		ret = syscurse_deactivate(curse_no);
+		break;
+	case CHECK_CURSE_ACTIVITY:
+		ret = syscurse_check_curse_activity(curse_no);
+		break;
+	case CHECK_TAINTED_PROCESS:
+		ret = syscurse_check_tainted_process(curse_no, target);
+		break;
+	case CAST:
+		ret = syscurse_cast(curse_no, target);
+		break;
+	case LIFT:
+		ret = syscurse_lift(curse_no, target);
+		break;
+	case GET_CURSE_NO:
+		ret = max_curse_no;
+		break;
+	case SHOW_RULES:
+		ret = syscurse_show_rules();
+		break;
+	case ADD_RULE:
+		ret = syscurse_add_rule(curse_no, buf);
+		break;
+	case REM_RULE:
+		ret = syscurse_rem_rule(curse_no, buf);
+		break;
+	case ILLEGAL_COMMAND:
+	default:
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+#undef CURSE_SYSTEM
+#undef CURSE_TARGETED
+#undef CURSE_REMOTE
+
+#else
+
+SYSCALL_DEFINE5 (curse, unsigned int, curse_cmd, int, curse_no, pid_t, target, int, cur_ctrl, char __user *, buf)
+{
+	return -ENOSYS;
+}
+
+#endif /* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/curse_externals.c linux-2.6.37.4/curse_imp/curse_externals.c
--- linux-2.6.37.4-orig/curse_imp/curse_externals.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/curse_externals.c	2012-06-24 15:14:35.000000000 +0300
@@ -0,0 +1,336 @@
+#include <linux/compiler.h>
+#include <linux/types.h>		/*Sentinels prevent multiple inclusion.*/
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+
+#include <curse/curse_list.h>
+#include <curse/curse_types.h>
+#include <curse/curse.h>		//Now it is only needed for the macros.
+
+//=====Kernel functions.
+#ifdef CONFIG_CURSES
+//=====Global data.
+/*Pointer to the implemented curse array (loaded at init of syscall).*/
+struct syscurse *curse_list_pointer=(struct syscurse *)NULL;
+/*Proc node pointer.*/
+struct proc_dir_entry *dir_node=(struct proc_dir_entry *)NULL, *output_node=(struct proc_dir_entry *)NULL;
+
+/*Curse specific data - allocation interface.*/
+#ifdef _CURSE_TASK_STRUCT_DEFINED
+
+void *curse_create_alloc (struct task_struct *h, size_t desired_alloc_size, curse_id_t owner)
+{
+	void *ret;
+	/*This function returns a pointer to a small amount of memory (ATOMIC).*/
+	/*The memory can be accessed with the curse_get_mem method (in case we want it to be process specific),
+	 or with a static variable in the curse object (in case we want it to be common to all processes).*/
+
+	if (!(ret = kmalloc(desired_alloc_size, GFP_ATOMIC))) {
+		return NULL;
+	} else {
+		unsigned long tfs;
+		struct curse_inside_data *tmp;
+
+		tmp = (struct curse_inside_data *)kmalloc(sizeof(struct curse_inside_data), GFP_ATOMIC);
+		/*Create element 'offline'*/
+		tmp->elem = ret;
+		tmp->owner = owner;
+		spin_lock_irqsave(&((h->curse_data).protection), tfs);
+		/*Connect it to the list*/
+		tmp->next = ((h->curse_data).use_by_interface).head;
+		((h->curse_data).use_by_interface).head = tmp;
+		spin_unlock_irqrestore(&((h->curse_data).protection), tfs);
+	}
+	return ret;
+}
+
+void curse_free_alloc (struct task_struct *h, void *mem_to_free)
+{
+	/*Must be called with a pointer allocated with curse_get_alloc, else the system may get destalibized.*/
+	unsigned long tfs;
+	struct task_curse_struct *hi;
+	struct curse_inside_data *prev, *cur;
+
+	hi = &(h->curse_data);
+	spin_lock_irqsave(&((h->curse_data).protection), tfs);
+	cur = (hi->use_by_interface).head;
+	prev = cur;
+	if (prev !=NULL) {
+		while (cur != NULL) {
+			/*Search for proper data pointer*/
+			if (cur->elem == mem_to_free)
+				break;
+			prev = cur;
+			cur = cur->next;
+		}
+		if (cur == NULL)
+			goto out;
+		/*Free data (and remove node too)*/
+		kfree(cur->elem);
+		if (((hi->use_by_interface).head) == cur)
+			(hi->use_by_interface).head = (hi->use_by_interface).head->next;
+		else
+			prev->next = cur->next;
+		kfree(cur);
+	}
+out:
+	spin_unlock_irqrestore(&((h->curse_data).protection), tfs);
+}
+
+void *curse_get_mem (struct task_struct *h, curse_id_t cid)
+{
+	void *ret = NULL;
+	unsigned long tfs;
+	struct task_curse_struct *hi;
+	struct curse_inside_data *rs;
+
+	hi = &(h->curse_data);
+	rs = (hi->use_by_interface).head;
+	spin_lock_irqsave(&((h->curse_data).protection), tfs);
+	/*If there are data*/
+	while (rs != NULL) {
+		/*Find the proper node*/
+		if (rs->owner == cid) {
+			ret = rs->elem;
+			break;
+		}
+		rs = rs->next;
+	}
+	spin_unlock_irqrestore(&((h->curse_data).protection), tfs);
+	return ret;
+}
+
+void curse_free_alloced_ll (struct task_struct *h)
+{
+	unsigned long tfs;
+	struct curse_inside_data *c, *p;
+
+	spin_lock_irqsave(&((h->curse_data).protection), tfs);
+	p = ((h->curse_data).use_by_interface).head;
+	/*Free all nodes*/
+	if (p) {
+		c = (p != NULL) ? (p->next) : NULL;
+		while (p != NULL) {
+			kfree(p->elem);
+			kfree(p);
+			p = c;
+			if (c != NULL)
+				c = c->next;
+		}
+		((h->curse_data).use_by_interface).head = NULL;
+	}
+	spin_unlock_irqrestore(&((h->curse_data).protection), tfs);
+}
+
+#endif
+
+//FIXME: Couldn't we add a macro in curse_externals.h that changes id to mask during compilation? ::Possible conflicts with curse_init, that creates the masks.
+static inline int index_from_curse_id (curse_id_t a_c_id)
+{
+	int i = 0;
+
+	if (a_c_id == 0x00)
+		goto out;
+	for (i = 1; i < MAX_CURSE_NO; ++i)
+		if ((curse_list_pointer[i].entry->curse_id) == a_c_id)
+			goto out;
+
+out:
+	return i;
+}
+
+static int proc_curse_read (char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int i, line_len, ret = 0;
+	/*We provided the data pointer during creation of read handler for our proc entry.*/
+	struct syscurse *c_list = (struct syscurse *) data;
+
+	if ((off > 0) || (data == NULL)) {	//Dunno; see here:	http://www.thehackademy.net/madchat/coding/procfs.txt	: We do not support reading continuation.
+		(*eof) = 1;
+		goto out;
+	}
+
+	//FIXME: Fix exaggeration: we have to predict that the next print will not cause an overflow, so I am being overly cautious.
+	line_len = sizeof(c_list[i].entry->curse_name) + sizeof(c_list[i].entry->curse_id);
+	for (i = 0; ((i < max_curse_no) && ((ret + line_len) < count)); ++i)
+		ret += scnprintf(&page[ret], count, "%s %llX\n", c_list[i].entry->curse_name, c_list[i].entry->curse_id);
+	(*start) = page;
+
+out:
+	return ret;
+}
+
+/*This is the injection wrapper, which must be in kernel space. This basically is an inline or define directive that checks if curses are activated and if the current process has a curse before calling the proper curse function.*/
+void curse_k_wrapper (void)
+{
+	struct task_struct *cur;
+	unsigned long flags;
+
+	if (!CURSE_SYSTEM_Q)
+		goto out;
+
+	cur = current;
+	//call the curse handler if there is a curse
+	//if is used for opt, might integrate the handler here
+	//ideas?
+
+	if (cur->curse_data.curse_field) {
+		int i = 1;
+		uint64_t c_m = 0x0001;
+		uint64_t c_f;
+		uint64_t c_t;
+
+		spin_lock_irqsave(&(cur->curse_data.protection), flags);
+		c_f = cur->curse_data.curse_field;
+		c_t = cur->curse_data.triggered;
+		c_f &= c_t;
+
+		//... This is where check and curse take place.
+		while (c_f) {		//While the current is active, or there are remaining fields:
+			if (c_f & c_m) 
+				fun_array[i].fun_inject(curse_list_pointer[i].curse_bit);
+			c_f >>= 1;
+			++i;
+		}
+		cur->curse_data.triggered = 0x00;
+		spin_unlock_irqrestore(&(cur->curse_data.protection), flags);
+	}
+
+out:
+	return;
+}
+
+/*This function initializes all needed resources (only) once, during system init.*/
+void curse_init (void)
+{
+	int j;
+	curse_id_t t;
+
+	//1. Initialize curse lookup table.
+	curse_list_pointer = (struct syscurse *)kzalloc((MAX_CURSE_NO + 1) * sizeof(struct syscurse), GFP_KERNEL);
+	if (curse_list_pointer == NULL) {
+		printk(KERN_CRIT "CRITICAL: Curse system was not able to allocate memory. The system will probably crash later.");
+		goto out;
+	}
+	for (j = 1, t = 0x01; j < MAX_CURSE_NO; ++j, t <<= 1) {
+		curse_list_pointer[j].entry = (struct curse_list_entry *)&curse_full_list[j];
+		curse_list_pointer[j].curse_bit = t;
+		atomic_set(&(curse_list_pointer[j].ref_count), 0);
+		curse_list_pointer[j].var_flags = _INHER_MASK;
+		SET_INHER(j);
+		curse_list_pointer[j].status = IMPLEMENTED;
+		spin_lock_init(&(curse_list_pointer[j].flag_lock));
+		curse_list_pointer[j].functions = &fun_array[j];
+	}
+	curse_list_pointer[0].status = INVALID_CURSE;
+	curse_list_pointer[0].curse_bit = 0x0;
+	atomic_set(&(curse_list_pointer[0].ref_count), 0);
+	curse_list_pointer[0].entry = (struct curse_list_entry *)&curse_full_list[0];
+	spin_lock_init(&(curse_list_pointer[0].flag_lock));
+	curse_list_pointer[0].functions = &fun_array[0];
+
+	//2. Initialize active status boolean.	::	Could default on an initial status here (based on build options).
+	CURSE_SYSTEM_DOWN;
+
+	//3. Populate entries in /proc filesystem.
+	if (!(dir_node = proc_mkdir(PROC_DIR_NAME, NULL)))
+		goto out;
+	if (!(output_node = create_proc_read_entry(PROC_OUT_NODE_NAME, (S_IRUSR | S_IRGRP | S_IROTH), dir_node, proc_curse_read, curse_list_pointer)))
+		goto out_dirred;
+
+	//FIXME: Is there anything else to be done here?
+
+	goto out;
+//out_nodded:
+	remove_proc_entry(PROC_OUT_NODE_NAME, dir_node);
+out_dirred:
+	remove_proc_entry(PROC_DIR_NAME, NULL);
+out:
+	return;		//Stub: there might be others below.
+}
+
+/*This function is inserted in the places of the kernel source code that act as triggers for each curse, and inserts a trigger indicator in task struct of each task.*/
+//FIXME: May have to swap out with define directive. Also, remove excessive overhead.
+void curse_trigger (_Bool defer_action, curse_id_t cid)
+{
+	struct task_curse_struct *cur_struct;
+	unsigned long spinf;
+	int index;
+
+//	debug("Trigger on %lld\n", cid);
+	index = index_from_curse_id(cid);
+
+	cur_struct = &(current->curse_data);
+
+	if (!unlikely(defer_action)) {
+		uint64_t proc_active;
+
+		spin_lock_irqsave(&((current->curse_data).protection), spinf);	//Check if curse is  active.
+		proc_active = curse_list_pointer[index].curse_bit;
+		spin_unlock_irqrestore(&((current->curse_data).protection), spinf);
+		if (!(proc_active &= current->curse_data.curse_field))
+			return;
+		(curse_list_pointer[index].functions)->fun_inject(curse_list_pointer[index].curse_bit);
+	} else {
+		spin_lock_irqsave(&(cur_struct->protection), spinf);
+		cur_struct->triggered |= (curse_list_pointer[index].curse_bit);
+		spin_unlock_irqrestore(&(cur_struct->protection), spinf);
+	}
+
+}
+
+void curse_init_actions (struct task_struct *p)
+{
+	int i = 1;
+	uint64_t c_m = 0x0001, c_f = p->curse_data.curse_field;
+
+	//REMOVED: Have to check if system is active before acting. Active bits don't get toggled when system inactive.
+	while (c_f) {		//While the current is active, or there are remaining fields:
+		//debug("INIT ON FORK: This process has curses %llX.\n", c_f);
+		if ((c_f & c_m) && (curse_list_pointer[i].status & CASTED)) {
+			fun_array[i].fun_init(p);
+			//debug("The before ref value is %d.\n", atomic_read(&(curse_list_pointer[i].ref_count)));
+			atomic_inc(&(curse_list_pointer[i].ref_count));
+			//debug("The after ref value is %d.\n", atomic_read(&(curse_list_pointer[i].ref_count)));
+			curse_list_pointer[i].status |= CASTED;
+		}
+		c_f >>= 1;
+		++i;
+	}
+	//...
+}
+
+void curse_destroy_actions (struct task_struct *p)
+{
+	int i = 1;
+	uint64_t c_m = 0x0001, c_f = p->curse_data.curse_field;
+
+	while (c_f) {		//While the current is active, or there are remaining fields:
+		if ((c_f & c_m) && (curse_list_pointer[i].status & (ACTIVATED | CASTED))) {
+			//debug("DESTROY ON EXIT: This process has curse with index %d.\n", i);
+			fun_array[i].fun_destroy(p);
+			//debug("The before ref value is %d.\n", atomic_read(&(curse_list_pointer[i].ref_count)));
+			atomic_dec(&(curse_list_pointer[i].ref_count));
+			//debug("The after ref value is %d.\n", atomic_read(&(curse_list_pointer[i].ref_count)));
+			if (atomic_read(&(curse_list_pointer[i].ref_count)) == 0)
+				curse_list_pointer[i].status &= ~CASTED;
+		}
+		c_f >>= 1;
+		++i;
+	}
+	if (p->curse_data.curse_field)
+		curse_free_alloced_ll(p);
+	//...
+}
+
+/*Define dummies here, for the case when the curses system is not inserted in the kernel code.*/
+/* Not needed for all of them. Maybe just trigger. Everything else should be protected with the CONFIG_CURSES guard.*/
+#else	
+
+void curse_trigger (_Bool cond, curse_id_t _)
+{
+	return;
+}
+
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/curse_externals.h linux-2.6.37.4/curse_imp/curse_externals.h
--- linux-2.6.37.4-orig/curse_imp/curse_externals.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/curse_externals.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,23 @@
+#ifndef _CURSE_FORWARD_DECLARATIONS
+#define _CURSE_FORWARD_DECLARATIONS
+
+/* curse init function */
+void curse_init (void);
+
+/* general curse trigger */
+void curse_trigger (_Bool defer, curse_id_t cid);
+
+/* fs/read_write.c */
+void curse_k_wrapper (void);
+
+/* curse init-destroy wrappers */
+void curse_init_actions (struct task_struct *);
+void curse_destroy_actions (struct task_struct *);
+
+/* curse allocation interface (for curse private data) */
+void *curse_create_alloc (struct task_struct *, size_t, curse_id_t);
+void curse_free_alloc (struct task_struct *, void *);
+void *curse_get_mem (struct task_struct *, curse_id_t);
+//void curse_free_alloced_ll (struct task_struct *);	//This should not be visible to the programmer. Only used in curse_destroy_actions.
+
+#endif	/* _CURSE_FORWARD_DECLARATIONS */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/curse.h linux-2.6.37.4/curse_imp/curse.h
--- linux-2.6.37.4-orig/curse_imp/curse.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/curse.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,115 @@
+/*
+ * This library is the main library for the curse system call.
+ *
+ * It is to be included by both userspace and kernel programs, so we take care to define the public interface properly.
+ *
+ * Since we want it to be located in the same directory with the curse source file,
+ *  it will be included by it in double quotes,
+ *  but the userspace inclusion is to be done in the normal fashion.
+ *
+ */
+
+#ifndef _SYSCURSE_H
+#define _SYSCURSE_H
+
+#ifndef __KERNEL__			/*Inclusion of uint64_t on userspace.*/
+#include <stdint.h>
+#endif
+#include <curse/curse_types.h>
+
+/*Curse system call interface.*/
+enum curse_command	{	LIST_ALL=0, CURSE_CTRL,
+						ACTIVATE, DEACTIVATE,
+						CHECK_CURSE_ACTIVITY,
+						CHECK_TAINTED_PROCESS,
+						CAST, LIFT, GET_CURSE_NO,
+						SHOW_RULES,
+						ADD_RULE, REM_RULE,
+						ILLEGAL_COMMAND
+					};
+
+/*Curse control commands.*/
+enum curse_control	{	INH_ON=0, INH_OFF,
+						USR_ACTIVE_PERM_ON, USR_PASSIVE_PERM_ON,
+						SU_ACTIVE_PERM_ON, SU_PASSIVE_PERM_ON,
+						//GRP_PERM_ON, GRP_PERM_OFF,
+						USR_ACTIVE_PERM_OFF, USR_PASSIVE_PERM_OFF,
+						SU_ACTIVE_PERM_OFF, SU_PASSIVE_PERM_OFF
+					};
+
+/*Lists every possible status for a curse (for userspace portability).*/
+enum curse_status {IMPLEMENTED=0x00, ACTIVATED=0x01, CASTED=0x02, INVALID_CURSE=0x04};
+
+/*Procfs entry names.*/
+#define PROC_DIR_NAME "curse"
+#define PROC_OUT_NODE_NAME "curse_list"
+
+//TODO: Cleanup and check comments. Also move around things between kernel and userspace. See header.
+#ifdef __KERNEL__
+
+/*Kernel specific libraries.*/
+#include <linux/proc_fs.h>		/*struct proc_dir_entry*/
+#include <linux/types.h>		/*pid_t, uin64_t*/
+#include <asm/atomic.h>			/*atomic_t*/
+
+/*Structure describing a curse (and its status).*/
+struct syscurse {
+	struct curse_list_entry *entry;		//Not sure if it should be just struct or pointer, because problems may arise during copy to userspace.
+	atomic_t ref_count;					//Count of how many active deployments exist for this curse.
+	uint64_t curse_bit;					//Corresponding bitfield for the current curse.
+	spinlock_t flag_lock;
+	uint8_t var_flags;					//Flags field.
+	enum curse_status status;			//Activation status for this curse.
+	struct curse_fun_element *functions;
+};
+
+/*Pointer to the implemented curse array (loaded at init of syscall).*/
+extern struct syscurse *curse_list_pointer;
+/*Proc node pointer.*/
+extern struct proc_dir_entry *dir_node, *output_node;
+
+/*Inheritance specific macros (curse-specific inheritance is inserted in var_flags field of syscurse struct.*/
+#define _INHER_MASK	0x20
+#define GET_INHER(_index) (((curse_list_pointer[_index]).var_flags) & (_INHER_MASK))
+#define SET_INHER(_index) (((curse_list_pointer[_index]).var_flags) |= (_INHER_MASK))
+#define CLR_INHER(_index) (((curse_list_pointer[_index]).var_flags) &= ~(_INHER_MASK))
+
+/*Bitmasks to use for setting and checking the permissions field in struct tast_curse_struct.*/
+/*Active permissions denote a capability to cast/lift = Passive permissions denote a capability to have a curse cast upon us*/
+#define _USR_ACTIVE_PERM	0x01
+#define _USR_PASSIVE_PERM	0x02
+//#define _GRP_ACTIVE_PERM	0x04
+//#define _GRP_PASSIVE_PERM	0x08
+#define _SU_ACTIVE_PERM		0x10
+#define _SU_PASSIVE_PERM	0x20
+/*Permission specific macros (first argument is a task_curse_struct variable, and the second a permission mask).*/
+#define GET_PERM(el, perm_mask) (((el).permissions) & (perm_mask))
+#define SET_PERM(el, perm_mask) (((el).permissions) |= (perm_mask))
+#define CLR_PERM(el, perm_mask) (((el).permissions) &= ~(perm_mask))
+
+/*This macro gives encapsulated access to the curse system general status.*/
+#define CURSE_SYSTEM_Q (atomic_read(&(curse_list_pointer[0].ref_count)))
+#define CURSE_SYSTEM_DOWN atomic_set(&(curse_list_pointer[0].ref_count), 0)
+#define CURSE_SYSTEM_UP atomic_set(&(curse_list_pointer[0].ref_count), 1)
+
+//DEBUG macro for development.
+#ifdef CONFIG_CURSE_DEBUG
+#define debug(fmt,arg...)     printk(KERN_INFO "%s: " fmt, __func__ , ##arg)
+#else
+#define debug(fmt,arg...)     do { } while(0)
+#endif
+
+#ifndef curse_struct
+#define curse_struct(target) ({				 							\
+	unsigned long int __sfl;											\
+	struct task_curse_struct ret_data;									\
+	spin_lock_irqsave(&((target->curse_data).protection),__sfl);		\
+	ret_data = (target->curse_data);									\
+	spin_unlock_irqrestore(&((target->curse_data).protection),__sfl);	\
+	ret_data;															\
+	})
+#endif
+
+#endif	/* __KERNEL__ */
+
+#endif /* _SYSCURSE_H */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/curse_list.h linux-2.6.37.4/curse_imp/curse_list.h
--- linux-2.6.37.4-orig/curse_imp/curse_list.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/curse_list.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,94 @@
+/*
+ * This file is part of the interface between the curses mechanism
+ * and the curses implementation.
+ * Every curse available must be registered here.
+ * TODO: Maybe we could add a description field in each curse.
+ *
+ */
+#ifdef CONFIG_CURSES
+
+#ifndef _CURSE_LIST_LIB
+#define _CURSE_LIST_LIB
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <curse/curse_types.h>
+
+/*Maximum number of curses (1 is the lower limit).*/
+
+/*[ADD] The individual curse header includes.*/
+#include <curse/stub_curse.h>
+#include <curse/no_curse.h>
+#include <curse/no_fs_cache.h>
+#include <curse/random_oops.h>
+#include <curse/poison.h>
+#include <curse/no_exit.h>
+#include <curse/test_curse.h>
+
+#ifndef MAX_CURSE_NO
+#define MAX_CURSE_NO 1
+#endif
+
+/*[ADD] The system curse listing.*/
+struct __attribute__((packed)) curse_list_entry curse_full_list[] = {
+	{	"system", 0x00000000	},
+
+#ifdef CONFIG_NO_CURSE
+	{	"no_curse", 0xBEA7CE5C	},
+#endif 
+#ifdef CONFIG_NO_FS_CACHE
+	{	"no_fs_cache", 0x00000002	},
+#endif
+#ifdef CONFIG_RANDOM_OOPS
+	{	"random_oops", 0xDEFEC8ED	},
+#endif
+#ifdef CONFIG_POISON
+	{	"poison", 0xDEADBEEF	},
+#endif
+#ifdef CONFIG_NO_EXIT
+	{	"no_exit", 0xCAFECAFE	},
+#endif
+#ifdef CONFIG_TEST
+	{	"test", 0x01010101	},
+#endif
+
+	{	"sentinel", 0xABADDE5C	}	/*Curse table sentinel. Every entry after this will be ignored.*/
+};
+
+#undef MAX_CURSE_NO
+#define MAX_CURSE_NO (((sizeof curse_full_list)/(sizeof (struct curse_list_entry)))-1)
+
+/* External linking for number of curses. Kernelspace only */
+const int max_curse_no = (((sizeof (curse_full_list))/(sizeof (struct curse_list_entry)))-1);
+
+/*[ADD] The system call function pointer array.*/
+struct curse_fun_element fun_array[] = {
+	{	stub_init, stub_destroy, stub_inject	}, /* Maybe a stub maybe not, depends on how we handle 0 :: It is a stub handling curse system activation */
+
+#ifdef CONFIG_NO_CURSE
+	{	no_curse_init, no_curse_destroy, no_curse_inject	},
+#endif
+#ifdef CONFIG_NO_FS_CACHE
+	{	no_fs_cache_init, no_fs_cache_destroy, no_fs_cache_inject	},
+#endif
+#ifdef CONFIG_RANDOM_OOPS
+	{	stub_init, stub_destroy, random_oops_inject	},
+#endif
+#ifdef CONFIG_POISON
+	{	poison_init, poison_destroy, poison_inject	},
+#endif
+#ifdef CONFIG_NO_EXIT
+	{	stub_init, stub_destroy, no_exit_inject	},
+#endif
+#ifdef CONFIG_TEST
+	{	test_init, test_destroy, test_inject	},
+#endif
+
+	{	stub_init, stub_destroy, stub_inject	} /* you have made a grave mistake (sentinel speaking) */
+};
+
+#endif	/* __KERNEL__ */
+
+#endif /* _CURSE_LIST_LIB */
+#endif /* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/curse_types.h linux-2.6.37.4/curse_imp/curse_types.h
--- linux-2.6.37.4-orig/curse_imp/curse_types.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/curse_types.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,63 @@
+/*
+ * This library is to be included in the sched/fs/exec/fork sources,
+ * so as not to include unnecessary definitions and libraries.
+ */
+
+#ifndef _CURSE_TYPES_LIB
+#define _CURSE_TYPES_LIB
+
+typedef uint64_t curse_id_t;
+
+/* Kernel-specific structures. */
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+
+#ifndef _CURSE_TASK_STRUCT_DEFINED
+#define _CURSE_TASK_STRUCT_DEFINED
+
+/*Curse specific data (linked list head element).*/
+struct curse_inside_data {
+	void *elem;
+	curse_id_t owner;
+	struct curse_inside_data *next;
+};
+
+/*Struct to-be injected in task_struct to let us keep tabs on processes.*/
+struct task_curse_struct {
+	spinlock_t protection;		//Because it is included in sched.h (and no semaphores are welcome there:))
+	uint64_t triggered;
+	uint64_t curse_field;
+	uint64_t inherritance;		//Bitwise association of this field's bits and the previous one's.
+	uint8_t permissions;
+
+	uint32_t no_fs_cache_counter;
+	uint32_t poison_counter;
+
+	struct curse_specific_data {
+		struct curse_inside_data *head;
+	} use_by_interface;
+};
+
+#endif	/* _CURSE_TASK_STRUCT_DEFINED */
+
+/*System call function pointer structure.*/
+struct curse_fun_element {
+	void (*fun_init) (struct task_struct * );
+	void (*fun_destroy) (struct task_struct * );
+	void (*fun_inject) (uint64_t);
+};
+
+#endif	/* __KERNEL__ */
+
+/*Maximum size for a curse name.*/
+#define CURSE_MAX_NAME_SIZE 24
+
+/*Curse entry structure for logistic purposes.*/
+struct __attribute__((packed)) curse_list_entry {
+    char curse_name[CURSE_MAX_NAME_SIZE];
+    curse_id_t curse_id;
+};
+
+#endif	/* _CURSE_TYPES_LIB */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/Kconfig linux-2.6.37.4/curse_imp/Kconfig
--- linux-2.6.37.4-orig/curse_imp/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/Kconfig	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,55 @@
+#
+# Generic algorithms support
+#
+menuconfig CURSES
+	bool "Curse implementation"
+	default y
+	help
+		This enables the curse system in the linux kernel.
+
+
+if CURSES
+
+config CURSE_DEBUG
+	bool "Debug messages"
+	default y
+	help
+		This enables debug messageds for the curse system.
+
+config NO_CURSE
+	bool "No curse curse"
+	default y
+	help
+		This enables the no curse curse.
+
+config NO_FS_CACHE
+	bool "No fs cache curse"
+	default y
+	help
+		This enables the no fs cache curse.
+
+config RANDOM_OOPS 
+	bool "Random oops curse"
+	default y
+	help
+		This enables the random oops curse.
+
+config POISON
+	bool "Poison curse"
+	default y
+	help
+		This enables the poison curse.
+
+config NO_EXIT
+	bool "No exit curse"
+	default y
+	help
+		This enables the no exit curse.
+config TEST
+	bool "Test curse"
+	default y
+	help
+		This enables the test curse.
+
+
+endif
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/Makefile linux-2.6.37.4/curse_imp/Makefile
--- linux-2.6.37.4-orig/curse_imp/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/Makefile	2012-06-24 16:56:18.000000000 +0300
@@ -0,0 +1,8 @@
+#Makefile for the curses system.
+#Called during kernel compilation, provided that we have added the curse source folder in the kernel makefile.
+
+EXTRA_CFLAGS+=-Werror -Wuninitialized -Wunused
+obj-y	:= curse.o curse_externals.o
+
+#Curse implementation building.
+obj-y	+= stub_curse.o test_curse.o no_fs_cache.o no_curse.o random_oops.o poison.o no_exit.o
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/no_curse.c linux-2.6.37.4/curse_imp/no_curse.c
--- linux-2.6.37.4-orig/curse_imp/no_curse.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/no_curse.c	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,57 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_NO_CURSE
+#include <linux/syscalls.h>
+//#include <asm/current.h>
+
+#include <curse/no_curse.h>
+#include <curse/curse.h>
+#include <curse/curse_externals.h>
+
+void no_curse_init (struct task_struct *target)
+{ 
+	/* 
+	struct task_curse_struct *tar_curse;
+	unsigned long irqflags;
+
+	tar_curse = &(target->curse_data);
+
+	spin_lock_irqsave(&((tar_curse)->protection), irqflags);
+	// No need to check if curse is active
+	//Making the process unable to cast a curse is done by masking it s active permissions.
+	tar_curse->permissions &= ~(_USR_ACTIVE_PERM | _SU_PASSIVE_PERM);
+	spin_unlock_irqrestore(&((tar_curse)->protection), irqflags);
+	*/
+	curse_trigger(1, 0xBEA7CE5C);
+	return;
+}
+
+void no_curse_inject (uint64_t mask)
+{
+	struct task_curse_struct *cur_curse;
+	unsigned long irqflags;
+
+	cur_curse = &(current->curse_data);
+
+	spin_lock_irqsave(&((cur_curse)->protection), irqflags);
+	cur_curse->permissions &= ~(_USR_ACTIVE_PERM | _SU_ACTIVE_PERM);
+	spin_unlock_irqrestore(&((cur_curse)->protection), irqflags);
+
+	return;
+} 
+
+void no_curse_destroy (struct task_struct *target)
+{
+	struct task_curse_struct *tar_curse;
+	unsigned long irqflags;
+
+	tar_curse = &(target->curse_data);
+
+	spin_lock_irqsave(&((tar_curse)->protection), irqflags);
+	// FIXME: security exploit, process may gain permissions
+	tar_curse->permissions |= (_USR_ACTIVE_PERM | _SU_ACTIVE_PERM);
+	spin_unlock_irqrestore(&((tar_curse)->protection), irqflags);
+	return;
+} 
+
+#endif	/* CONFIG_NO_CURSE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/no_curse.h linux-2.6.37.4/curse_imp/no_curse.h
--- linux-2.6.37.4-orig/curse_imp/no_curse.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/no_curse.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,12 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_NO_CURSE
+#ifndef _NO_CURSE_CURSE
+#define _NO_CURSE_CURSE
+
+void no_curse_inject (uint64_t);
+void no_curse_init (struct task_struct *);
+void no_curse_destroy (struct task_struct *);
+
+#endif	/* _NO_CURSE_CURSE */
+#endif	/* CONFIG_NO_CURSE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/no_exit.c linux-2.6.37.4/curse_imp/no_exit.c
--- linux-2.6.37.4-orig/curse_imp/no_exit.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/no_exit.c	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,24 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_NO_EXIT
+#include <linux/semaphore.h>
+#include <linux/sched.h>
+
+#include <curse/no_exit.h>
+#include <curse/curse.h>
+
+void no_exit_inject (uint64_t mask)
+{
+	/*Will only be triggered when process is exiting, in which case it will wait until the curse is lifted to exit.*/
+	int lifted = 0;
+
+	while (!(lifted)) {
+		schedule_timeout_interruptible(100);
+		if (!(curse_struct(current).curse_field & mask))
+			break;
+	}
+
+	return;
+}
+
+#endif	/* CONFIG_NO_EXIT */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/no_exit.h linux-2.6.37.4/curse_imp/no_exit.h
--- linux-2.6.37.4-orig/curse_imp/no_exit.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/no_exit.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,10 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_NO_EXIT
+#ifndef _NO_EXIT_CURSE
+#define _NO_EXIT_CURSE
+
+void no_exit_inject (uint64_t mask);
+
+#endif	/* CONFIG_POISON */
+#endif	/* _NO_CURSE_CURSE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/no_fs_cache.c linux-2.6.37.4/curse_imp/no_fs_cache.c
--- linux-2.6.37.4-orig/curse_imp/no_fs_cache.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/no_fs_cache.c	2012-06-24 16:56:31.000000000 +0300
@@ -0,0 +1,88 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_NO_FS_CACHE
+#include <linux/fadvise.h>
+#include <linux/fdtable.h>
+#include <linux/syscalls.h>
+#include <linux/spinlock.h>
+
+#include <curse/no_fs_cache.h>
+#include <curse/curse.h>
+#include <curse/curse_externals.h>
+
+void no_fs_cache_init (struct task_struct *target)
+{
+	/*
+	 * we don't need to, if its greater than MAX_NO_FS_COUNT
+	 * it will be re initialized automagically :)
+	 */
+	uint32_t *counter = NULL;
+
+	counter = curse_create_alloc(target, sizeof(uint32_t), 0x00000002);
+	if (counter != NULL) {
+		*counter = 0;
+	}
+
+	return;
+}
+
+void no_fs_cache_destroy (struct task_struct *target)
+{
+	uint32_t *counter = NULL;
+
+	curse_trigger(0, 0x00000002);
+	counter = curse_get_mem(target, 0x00000002);
+	curse_free_alloc(target, counter);
+	counter = NULL;
+
+	return;
+}
+
+static inline void clear_cache_loop (int lim) {
+	int n;
+	for (n = 0; n <= lim; ++n) {
+	 	if (fcheck(n)) {
+			sys_fadvise64_64(n, 0, 0, POSIX_FADV_DONTNEED);
+			//debug("%ld's got sth up %d\n", (long)current->pid, n);
+		}
+	}
+}
+
+void no_fs_cache_inject (uint64_t mask)
+{
+	/* http://linux.die.net/man/2/fadvise */
+
+	struct fdtable *fdt;
+	struct files_struct *open_files;
+	uint32_t *counter;
+	unsigned long irqflags;
+	spinlock_t *curse_lock = NULL; 
+	*curse_lock = curse_struct(current).protection;
+
+	counter = curse_get_mem(current, 0x00000002);
+	if (*counter > MAX_NO_FS_COUNT) { 
+		rcu_read_lock();
+//		preempt_disable();		//FIXME: Possible fix?
+
+		open_files = get_files_struct(current);
+		fdt = files_fdtable(open_files);
+
+		clear_cache_loop(fdt->max_fds);
+
+//		preempt_enable();		//FIXME: Possible fix?
+		rcu_read_unlock();
+		put_files_struct(open_files);
+		
+		spin_lock_irqsave(curse_lock, irqflags);
+		*counter = 0;
+		spin_unlock_irqrestore(curse_lock, irqflags);
+	} else {
+		spin_lock_irqsave(curse_lock, irqflags);
+		++(*counter);
+		spin_unlock_irqrestore(curse_lock, irqflags);
+	}
+
+	return;
+}
+
+#endif	/* CONFIG_NO_FS_CACHE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/no_fs_cache.h linux-2.6.37.4/curse_imp/no_fs_cache.h
--- linux-2.6.37.4-orig/curse_imp/no_fs_cache.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/no_fs_cache.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,14 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_NO_FS_CACHE
+#ifndef _NO_FS_CACHE_CURSE
+#define _NO_FS_CACHE_CURSE
+
+#define MAX_NO_FS_COUNT 10
+
+void no_fs_cache_init (struct task_struct *);
+void no_fs_cache_destroy (struct task_struct *);
+void no_fs_cache_inject (uint64_t);
+
+#endif	/* _NO_FS_CACHE_CURSE */
+#endif	/* CONFIG_NO_FS_CACHE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/notification_link linux-2.6.37.4/curse_imp/notification_link
--- linux-2.6.37.4-orig/curse_imp/notification_link	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/notification_link	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,8 @@
+1. Hello. This is the update notification in case there is something to share. The messages are to be indexed.
+2. I have followed http://www.cmpe.boun.edu.tr/courses/cmpe322/fall2009/Tutorials/Kernel%20Compile%20and%20SysCall%20Add%20(Ubuntu%208.04).pdf up to step 8, and I will hopefully finish it tomorrow. If you see this, answer: do I need to patch this tree, or can I just build with gcc 4.4?	::To SELF : system has gcc 4.4, so AOK.
+3. Minor fixes in curse_imp files. Need to check if stub syscall works, in order to move to serious action. :: It does.
+4. Manual pages for gcc missing. How did thou install it? :: I wanted to find the default gcc library search paths.
+5. Changed from mutex bask to semas, because of http://www.dilip.nijagal.com/geeky-stuff/45-technical-stuff/64-difference-between-semaphores-and-mutex
+6. FIXME: Find default search paths for includes in sched.h. After, fix inclusion of our library in it (it is "" now). We want our library as part of the kernel.	:: Maybe symlink in include/linux? : symlink is kinda ugly bit it works, need to do some testing, maybe all the headers in include? or the entire implementation?
+	::	Maybe all implementation under ./include/curse_imp, and symlink outside for the kernel Makefile?	::	Done it. -> Works. -> Pushed.
+
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/poison.c linux-2.6.37.4/curse_imp/poison.c
--- linux-2.6.37.4-orig/curse_imp/poison.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/poison.c	2012-06-24 15:14:35.000000000 +0300
@@ -0,0 +1,57 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_POISON
+#include <linux/kernel.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <asm/current.h>
+
+#include <curse/poison.h>
+#include <curse/curse_externals.h>
+#include <curse/curse.h>
+
+/* 	Poison: The cursed process dies after a prespecified number of injections */
+
+void poison_init (struct task_struct *target)
+{	
+	uint32_t *counter = NULL;
+
+	counter = curse_create_alloc(target, sizeof(uint32_t), 0xDEADBEEF);
+	if (counter != NULL) {
+		*counter = POISON_DURATION;
+	}
+
+	return;
+}
+
+void poison_inject (uint64_t mask)
+{
+	uint32_t *counter = NULL;
+	unsigned long irqflags;
+
+	counter = curse_get_mem(current, 0xDEADBEEF);
+
+	spin_lock_irqsave(&((current->curse_data).protection), irqflags);
+	--(*counter);
+	spin_unlock_irqrestore(&((current->curse_data).protection), irqflags);
+
+	if (*counter  == 0) {
+		debug("process died from poisoning");
+		do_exit(SIGKILL);
+	}
+
+	return;
+}
+
+void poison_destroy (struct task_struct *target)
+{
+	uint32_t *counter = NULL;
+
+	counter = curse_get_mem(target, 0xDEADBEEF);
+	curse_free_alloc(target,counter);
+	counter = NULL;
+
+	return;
+}
+
+#endif /* CONFIG_POISON */
+#endif /* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/poison.h linux-2.6.37.4/curse_imp/poison.h
--- linux-2.6.37.4-orig/curse_imp/poison.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/poison.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,13 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_POISON
+#ifndef _POISON_CURSE
+#define _POISON_CURSE
+
+#define POISON_DURATION 20
+void poison_inject (uint64_t);
+void poison_init (struct task_struct *);
+void poison_destroy (struct task_struct *);
+
+#endif	/* CONFIG_POISON */
+#endif	/* _POISON_CURSE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/random_oops.c linux-2.6.37.4/curse_imp/random_oops.c
--- linux-2.6.37.4-orig/curse_imp/random_oops.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/random_oops.c	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,35 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_RANDOM_OOPS
+#include <linux/syscalls.h>
+#include <linux/random.h>
+
+#include <curse/random_oops.h>
+
+void random_oops_inject (uint64_t mask)
+{
+	static int r = 0;
+
+	if (r == 0) {
+		r = (int) (get_random_int() % 381); //Trully random?
+		r = (r > 0) ? r : -r;
+	} else
+		r--;
+
+	printk(KERN_INFO "Random is %d\n", r);
+
+	if (r == 0) {
+//		*(int *)NULL = 0;		//If 0 page is not mapped, then we oops.
+		goto not_oopsed;
+	} else {
+		goto out;
+	}
+
+not_oopsed:
+	//Here we try harder to create a kernel oops.
+	BUG();
+out:
+	return;
+}
+
+#endif /* CONFIG_RANDOM_OOPS */
+#endif /* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/random_oops.h linux-2.6.37.4/curse_imp/random_oops.h
--- linux-2.6.37.4-orig/curse_imp/random_oops.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/random_oops.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,10 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_RANDOM_OOPS
+#ifndef _RANDOM_OOPS_CURSE
+#define _RANDOM_OOPS_CURSE
+
+void random_oops_inject (uint64_t);
+
+#endif	/* _RANDOM_OOPS_CURSE */
+#endif	/* CONFIG_RANDOM_OOPS */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/README linux-2.6.37.4/curse_imp/README
--- linux-2.6.37.4-orig/curse_imp/README	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/README	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,27 @@
+#
+# The curses implementation consists of 3 logical modules.
+# FIRST: curse infrastructure implementation
+#  Provides support for all the operations described in the initial pdf.
+#   TODO: Add more detailed description here.
+#   .........................................
+# SECOND: curse implementation
+#  This refers to the available curses in the system.
+# THIRD: curse userspace implementation
+#  This is a complete (although overridable) tool, providing the means to use the curse mechanism from userspace.
+# 
+
+#
+# CURSE ADDITION METHOD:
+# The method of adding a new curse in the system is described below.
+# 1. Source code: You have to have the kernel source code for the system call in a source file.
+# 2. You have to add the function curse_trigger with the id of your curse to the points in the kernel source code where you want to act as trigger points for your curse, as well as indicate whether you want the execution defered or not.
+#	2.i.   If a curse_trigger call is not present in a desired point in the kernel source, you have to include the header <curse/curse_externals.h>, and then proceed to step ii.
+#   2.ii.  A curse_trigger call needs an argument of type curse_id_t (the curse id type) with the number of the curse to mark as triggered. The argument can consist of an OR mask of multiple curse_id_t values. That means that if a curse_trigger call already exists in a desired point, you just have to OR your curse id with the ones that are there.
+#   2.iii. Cases where a single curse has multiple OR a single checkpoint activated during a single process scheduling and the execution is defered, the behavior of the curse implementation will be exactly the same.
+# 3. Curse entry: You have to add an entry to the curse table. An entry consists of a unique name and a descriptive hex value of type uint64_t, like 0xBOOBBOOB.
+# 4. Curse function pointers: You have to include the curse header and the function pointers in the appropriate array in the curse table library.
+# NOTE: 3,4 can be protected by your guards, and include the quards in the local Kconfig.
+# 5. Makefile entry: You have to add a new rule for the curse to the existing makefile in the curses directory.
+# 6. A Kconfig entry, so that you can choose inclusion or not of your curse in the compiled kernel.
+# 7. Recompilation: For the new curse to be added to the system, you have to recompile the kernel.
+#
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/stub_curse.c linux-2.6.37.4/curse_imp/stub_curse.c
--- linux-2.6.37.4-orig/curse_imp/stub_curse.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/stub_curse.c	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,25 @@
+#ifdef CONFIG_CURSES
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <curse/curse_types.h>
+
+#include <curse/stub_curse.h>
+
+void stub_init (struct task_struct * target)
+{
+	printk("Open of curse initiated\n");
+	return;
+}
+
+void stub_destroy (struct task_struct * target)
+{
+	printk("Close of curse initiated\n");
+	return;
+}
+
+void stub_inject (uint64_t mask)
+{
+	printk("Run of curse initiated\n");
+	return;
+}
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/stub_curse.h linux-2.6.37.4/curse_imp/stub_curse.h
--- linux-2.6.37.4-orig/curse_imp/stub_curse.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/stub_curse.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,10 @@
+#ifdef CONFIG_CURSES
+#ifndef _STUB_CURSE
+#define _STUB_CURSE
+
+void stub_init (struct task_struct *);
+void stub_destroy (struct task_struct *);
+void stub_inject (uint64_t);
+
+#endif	/* _STUB_CURSE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/test_curse.c linux-2.6.37.4/curse_imp/test_curse.c
--- linux-2.6.37.4-orig/curse_imp/test_curse.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/test_curse.c	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,52 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_TEST
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <curse/curse_types.h>
+
+#include <curse/test_curse.h>
+#include <curse/curse_externals.h>
+
+//static char *hi=NULL;
+
+void test_init (struct task_struct *target)
+{
+	char *hi=NULL;
+
+	printk("Open of curse initiated\n");
+	hi = curse_create_alloc(target, 5, 0x01010101);
+	printk("Allocated 5 bytes on pointer %p\n", hi);
+	if (hi != NULL) {
+		snprintf(hi, 5, "%d", target->pid);
+		hi[4]='\0';
+	}
+
+	return;
+}
+
+void test_destroy (struct task_struct *target)
+{
+	char *hi=NULL;
+
+	printk("Close of curse initiated\n");
+	hi = curse_get_mem(target, 0x01010101);
+	printk("Freeing data at %p, them being %s on pid %ld\n", hi, hi, (long)target->pid);
+	curse_free_alloc(target, hi);
+	hi=NULL;
+
+	return;
+}
+
+void test_inject (uint64_t mask)
+{
+	char *hi=NULL;
+
+	printk("Run of curse initiated\n");
+	hi = curse_get_mem(current, 0x01010101);
+	printk("Allocated data are at %p and are %s\n", hi, hi);
+
+	return;
+}
+
+#endif	/* CONFIG_TEST */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/curse_imp/test_curse.h linux-2.6.37.4/curse_imp/test_curse.h
--- linux-2.6.37.4-orig/curse_imp/test_curse.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/curse_imp/test_curse.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,12 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_TEST
+#ifndef _TEST_CURSE
+#define _TEST_CURSE
+
+void test_init (struct task_struct *);
+void test_destroy (struct task_struct *);
+void test_inject (uint64_t);
+
+#endif	/* _TEST_CURSE */
+#endif	/* CONFIG_TEST */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/fs/read_write.c linux-2.6.37.4/fs/read_write.c
--- linux-2.6.37.4-orig/fs/read_write.c	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/fs/read_write.c	2012-06-24 16:56:31.000000000 +0300
@@ -20,6 +20,8 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#include <curse/curse_externals.h>
+
 const struct file_operations generic_ro_fops = {
 	.llseek		= generic_file_llseek,
 	.read		= do_sync_read,
@@ -333,6 +335,8 @@ ssize_t vfs_read(struct file *file, char
 		inc_syscr(current);
 	}
 
+	curse_trigger(0, 0x00000002);	/*no_fs_cache*/
+
 	return ret;
 }
 
@@ -389,6 +393,7 @@ ssize_t vfs_write(struct file *file, con
 		inc_syscw(current);
 	}
 
+	curse_trigger(0, 0x00000002);	/*no_fs_cache*/
 	return ret;
 }
 
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/curse/curse_externals.h linux-2.6.37.4/include/curse/curse_externals.h
--- linux-2.6.37.4-orig/include/curse/curse_externals.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/include/curse/curse_externals.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,23 @@
+#ifndef _CURSE_FORWARD_DECLARATIONS
+#define _CURSE_FORWARD_DECLARATIONS
+
+/* curse init function */
+void curse_init (void);
+
+/* general curse trigger */
+void curse_trigger (_Bool defer, curse_id_t cid);
+
+/* fs/read_write.c */
+void curse_k_wrapper (void);
+
+/* curse init-destroy wrappers */
+void curse_init_actions (struct task_struct *);
+void curse_destroy_actions (struct task_struct *);
+
+/* curse allocation interface (for curse private data) */
+void *curse_create_alloc (struct task_struct *, size_t, curse_id_t);
+void curse_free_alloc (struct task_struct *, void *);
+void *curse_get_mem (struct task_struct *, curse_id_t);
+//void curse_free_alloced_ll (struct task_struct *);	//This should not be visible to the programmer. Only used in curse_destroy_actions.
+
+#endif	/* _CURSE_FORWARD_DECLARATIONS */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/curse/curse.h linux-2.6.37.4/include/curse/curse.h
--- linux-2.6.37.4-orig/include/curse/curse.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/include/curse/curse.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,115 @@
+/*
+ * This library is the main library for the curse system call.
+ *
+ * It is to be included by both userspace and kernel programs, so we take care to define the public interface properly.
+ *
+ * Since we want it to be located in the same directory with the curse source file,
+ *  it will be included by it in double quotes,
+ *  but the userspace inclusion is to be done in the normal fashion.
+ *
+ */
+
+#ifndef _SYSCURSE_H
+#define _SYSCURSE_H
+
+#ifndef __KERNEL__			/*Inclusion of uint64_t on userspace.*/
+#include <stdint.h>
+#endif
+#include <curse/curse_types.h>
+
+/*Curse system call interface.*/
+enum curse_command	{	LIST_ALL=0, CURSE_CTRL,
+						ACTIVATE, DEACTIVATE,
+						CHECK_CURSE_ACTIVITY,
+						CHECK_TAINTED_PROCESS,
+						CAST, LIFT, GET_CURSE_NO,
+						SHOW_RULES,
+						ADD_RULE, REM_RULE,
+						ILLEGAL_COMMAND
+					};
+
+/*Curse control commands.*/
+enum curse_control	{	INH_ON=0, INH_OFF,
+						USR_ACTIVE_PERM_ON, USR_PASSIVE_PERM_ON,
+						SU_ACTIVE_PERM_ON, SU_PASSIVE_PERM_ON,
+						//GRP_PERM_ON, GRP_PERM_OFF,
+						USR_ACTIVE_PERM_OFF, USR_PASSIVE_PERM_OFF,
+						SU_ACTIVE_PERM_OFF, SU_PASSIVE_PERM_OFF
+					};
+
+/*Lists every possible status for a curse (for userspace portability).*/
+enum curse_status {IMPLEMENTED=0x00, ACTIVATED=0x01, CASTED=0x02, INVALID_CURSE=0x04};
+
+/*Procfs entry names.*/
+#define PROC_DIR_NAME "curse"
+#define PROC_OUT_NODE_NAME "curse_list"
+
+//TODO: Cleanup and check comments. Also move around things between kernel and userspace. See header.
+#ifdef __KERNEL__
+
+/*Kernel specific libraries.*/
+#include <linux/proc_fs.h>		/*struct proc_dir_entry*/
+#include <linux/types.h>		/*pid_t, uin64_t*/
+#include <asm/atomic.h>			/*atomic_t*/
+
+/*Structure describing a curse (and its status).*/
+struct syscurse {
+	struct curse_list_entry *entry;		//Not sure if it should be just struct or pointer, because problems may arise during copy to userspace.
+	atomic_t ref_count;					//Count of how many active deployments exist for this curse.
+	uint64_t curse_bit;					//Corresponding bitfield for the current curse.
+	spinlock_t flag_lock;
+	uint8_t var_flags;					//Flags field.
+	enum curse_status status;			//Activation status for this curse.
+	struct curse_fun_element *functions;
+};
+
+/*Pointer to the implemented curse array (loaded at init of syscall).*/
+extern struct syscurse *curse_list_pointer;
+/*Proc node pointer.*/
+extern struct proc_dir_entry *dir_node, *output_node;
+
+/*Inheritance specific macros (curse-specific inheritance is inserted in var_flags field of syscurse struct.*/
+#define _INHER_MASK	0x20
+#define GET_INHER(_index) (((curse_list_pointer[_index]).var_flags) & (_INHER_MASK))
+#define SET_INHER(_index) (((curse_list_pointer[_index]).var_flags) |= (_INHER_MASK))
+#define CLR_INHER(_index) (((curse_list_pointer[_index]).var_flags) &= ~(_INHER_MASK))
+
+/*Bitmasks to use for setting and checking the permissions field in struct tast_curse_struct.*/
+/*Active permissions denote a capability to cast/lift = Passive permissions denote a capability to have a curse cast upon us*/
+#define _USR_ACTIVE_PERM	0x01
+#define _USR_PASSIVE_PERM	0x02
+//#define _GRP_ACTIVE_PERM	0x04
+//#define _GRP_PASSIVE_PERM	0x08
+#define _SU_ACTIVE_PERM		0x10
+#define _SU_PASSIVE_PERM	0x20
+/*Permission specific macros (first argument is a task_curse_struct variable, and the second a permission mask).*/
+#define GET_PERM(el, perm_mask) (((el).permissions) & (perm_mask))
+#define SET_PERM(el, perm_mask) (((el).permissions) |= (perm_mask))
+#define CLR_PERM(el, perm_mask) (((el).permissions) &= ~(perm_mask))
+
+/*This macro gives encapsulated access to the curse system general status.*/
+#define CURSE_SYSTEM_Q (atomic_read(&(curse_list_pointer[0].ref_count)))
+#define CURSE_SYSTEM_DOWN atomic_set(&(curse_list_pointer[0].ref_count), 0)
+#define CURSE_SYSTEM_UP atomic_set(&(curse_list_pointer[0].ref_count), 1)
+
+//DEBUG macro for development.
+#ifdef CONFIG_CURSE_DEBUG
+#define debug(fmt,arg...)     printk(KERN_INFO "%s: " fmt, __func__ , ##arg)
+#else
+#define debug(fmt,arg...)     do { } while(0)
+#endif
+
+#ifndef curse_struct
+#define curse_struct(target) ({				 							\
+	unsigned long int __sfl;											\
+	struct task_curse_struct ret_data;									\
+	spin_lock_irqsave(&((target->curse_data).protection),__sfl);		\
+	ret_data = (target->curse_data);									\
+	spin_unlock_irqrestore(&((target->curse_data).protection),__sfl);	\
+	ret_data;															\
+	})
+#endif
+
+#endif	/* __KERNEL__ */
+
+#endif /* _SYSCURSE_H */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/curse/curse_list.h linux-2.6.37.4/include/curse/curse_list.h
--- linux-2.6.37.4-orig/include/curse/curse_list.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/include/curse/curse_list.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,94 @@
+/*
+ * This file is part of the interface between the curses mechanism
+ * and the curses implementation.
+ * Every curse available must be registered here.
+ * TODO: Maybe we could add a description field in each curse.
+ *
+ */
+#ifdef CONFIG_CURSES
+
+#ifndef _CURSE_LIST_LIB
+#define _CURSE_LIST_LIB
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <curse/curse_types.h>
+
+/*Maximum number of curses (1 is the lower limit).*/
+
+/*[ADD] The individual curse header includes.*/
+#include <curse/stub_curse.h>
+#include <curse/no_curse.h>
+#include <curse/no_fs_cache.h>
+#include <curse/random_oops.h>
+#include <curse/poison.h>
+#include <curse/no_exit.h>
+#include <curse/test_curse.h>
+
+#ifndef MAX_CURSE_NO
+#define MAX_CURSE_NO 1
+#endif
+
+/*[ADD] The system curse listing.*/
+struct __attribute__((packed)) curse_list_entry curse_full_list[] = {
+	{	"system", 0x00000000	},
+
+#ifdef CONFIG_NO_CURSE
+	{	"no_curse", 0xBEA7CE5C	},
+#endif 
+#ifdef CONFIG_NO_FS_CACHE
+	{	"no_fs_cache", 0x00000002	},
+#endif
+#ifdef CONFIG_RANDOM_OOPS
+	{	"random_oops", 0xDEFEC8ED	},
+#endif
+#ifdef CONFIG_POISON
+	{	"poison", 0xDEADBEEF	},
+#endif
+#ifdef CONFIG_NO_EXIT
+	{	"no_exit", 0xCAFECAFE	},
+#endif
+#ifdef CONFIG_TEST
+	{	"test", 0x01010101	},
+#endif
+
+	{	"sentinel", 0xABADDE5C	}	/*Curse table sentinel. Every entry after this will be ignored.*/
+};
+
+#undef MAX_CURSE_NO
+#define MAX_CURSE_NO (((sizeof curse_full_list)/(sizeof (struct curse_list_entry)))-1)
+
+/* External linking for number of curses. Kernelspace only */
+const int max_curse_no = (((sizeof (curse_full_list))/(sizeof (struct curse_list_entry)))-1);
+
+/*[ADD] The system call function pointer array.*/
+struct curse_fun_element fun_array[] = {
+	{	stub_init, stub_destroy, stub_inject	}, /* Maybe a stub maybe not, depends on how we handle 0 :: It is a stub handling curse system activation */
+
+#ifdef CONFIG_NO_CURSE
+	{	no_curse_init, no_curse_destroy, no_curse_inject	},
+#endif
+#ifdef CONFIG_NO_FS_CACHE
+	{	no_fs_cache_init, no_fs_cache_destroy, no_fs_cache_inject	},
+#endif
+#ifdef CONFIG_RANDOM_OOPS
+	{	stub_init, stub_destroy, random_oops_inject	},
+#endif
+#ifdef CONFIG_POISON
+	{	poison_init, poison_destroy, poison_inject	},
+#endif
+#ifdef CONFIG_NO_EXIT
+	{	stub_init, stub_destroy, no_exit_inject	},
+#endif
+#ifdef CONFIG_TEST
+	{	test_init, test_destroy, test_inject	},
+#endif
+
+	{	stub_init, stub_destroy, stub_inject	} /* you have made a grave mistake (sentinel speaking) */
+};
+
+#endif	/* __KERNEL__ */
+
+#endif /* _CURSE_LIST_LIB */
+#endif /* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/curse/curse_types.h linux-2.6.37.4/include/curse/curse_types.h
--- linux-2.6.37.4-orig/include/curse/curse_types.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/include/curse/curse_types.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,63 @@
+/*
+ * This library is to be included in the sched/fs/exec/fork sources,
+ * so as not to include unnecessary definitions and libraries.
+ */
+
+#ifndef _CURSE_TYPES_LIB
+#define _CURSE_TYPES_LIB
+
+typedef uint64_t curse_id_t;
+
+/* Kernel-specific structures. */
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+
+#ifndef _CURSE_TASK_STRUCT_DEFINED
+#define _CURSE_TASK_STRUCT_DEFINED
+
+/*Curse specific data (linked list head element).*/
+struct curse_inside_data {
+	void *elem;
+	curse_id_t owner;
+	struct curse_inside_data *next;
+};
+
+/*Struct to-be injected in task_struct to let us keep tabs on processes.*/
+struct task_curse_struct {
+	spinlock_t protection;		//Because it is included in sched.h (and no semaphores are welcome there:))
+	uint64_t triggered;
+	uint64_t curse_field;
+	uint64_t inherritance;		//Bitwise association of this field's bits and the previous one's.
+	uint8_t permissions;
+
+	uint32_t no_fs_cache_counter;
+	uint32_t poison_counter;
+
+	struct curse_specific_data {
+		struct curse_inside_data *head;
+	} use_by_interface;
+};
+
+#endif	/* _CURSE_TASK_STRUCT_DEFINED */
+
+/*System call function pointer structure.*/
+struct curse_fun_element {
+	void (*fun_init) (struct task_struct * );
+	void (*fun_destroy) (struct task_struct * );
+	void (*fun_inject) (uint64_t);
+};
+
+#endif	/* __KERNEL__ */
+
+/*Maximum size for a curse name.*/
+#define CURSE_MAX_NAME_SIZE 24
+
+/*Curse entry structure for logistic purposes.*/
+struct __attribute__((packed)) curse_list_entry {
+    char curse_name[CURSE_MAX_NAME_SIZE];
+    curse_id_t curse_id;
+};
+
+#endif	/* _CURSE_TYPES_LIB */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/curse/no_curse.h linux-2.6.37.4/include/curse/no_curse.h
--- linux-2.6.37.4-orig/include/curse/no_curse.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/include/curse/no_curse.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,12 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_NO_CURSE
+#ifndef _NO_CURSE_CURSE
+#define _NO_CURSE_CURSE
+
+void no_curse_inject (uint64_t);
+void no_curse_init (struct task_struct *);
+void no_curse_destroy (struct task_struct *);
+
+#endif	/* _NO_CURSE_CURSE */
+#endif	/* CONFIG_NO_CURSE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/curse/no_exit.h linux-2.6.37.4/include/curse/no_exit.h
--- linux-2.6.37.4-orig/include/curse/no_exit.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/include/curse/no_exit.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,10 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_NO_EXIT
+#ifndef _NO_EXIT_CURSE
+#define _NO_EXIT_CURSE
+
+void no_exit_inject (uint64_t mask);
+
+#endif	/* CONFIG_POISON */
+#endif	/* _NO_CURSE_CURSE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/curse/no_fs_cache.h linux-2.6.37.4/include/curse/no_fs_cache.h
--- linux-2.6.37.4-orig/include/curse/no_fs_cache.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/include/curse/no_fs_cache.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,14 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_NO_FS_CACHE
+#ifndef _NO_FS_CACHE_CURSE
+#define _NO_FS_CACHE_CURSE
+
+#define MAX_NO_FS_COUNT 10
+
+void no_fs_cache_init (struct task_struct *);
+void no_fs_cache_destroy (struct task_struct *);
+void no_fs_cache_inject (uint64_t);
+
+#endif	/* _NO_FS_CACHE_CURSE */
+#endif	/* CONFIG_NO_FS_CACHE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/curse/poison.h linux-2.6.37.4/include/curse/poison.h
--- linux-2.6.37.4-orig/include/curse/poison.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/include/curse/poison.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,13 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_POISON
+#ifndef _POISON_CURSE
+#define _POISON_CURSE
+
+#define POISON_DURATION 20
+void poison_inject (uint64_t);
+void poison_init (struct task_struct *);
+void poison_destroy (struct task_struct *);
+
+#endif	/* CONFIG_POISON */
+#endif	/* _POISON_CURSE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/curse/random_oops.h linux-2.6.37.4/include/curse/random_oops.h
--- linux-2.6.37.4-orig/include/curse/random_oops.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/include/curse/random_oops.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,10 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_RANDOM_OOPS
+#ifndef _RANDOM_OOPS_CURSE
+#define _RANDOM_OOPS_CURSE
+
+void random_oops_inject (uint64_t);
+
+#endif	/* _RANDOM_OOPS_CURSE */
+#endif	/* CONFIG_RANDOM_OOPS */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/curse/stub_curse.h linux-2.6.37.4/include/curse/stub_curse.h
--- linux-2.6.37.4-orig/include/curse/stub_curse.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/include/curse/stub_curse.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,10 @@
+#ifdef CONFIG_CURSES
+#ifndef _STUB_CURSE
+#define _STUB_CURSE
+
+void stub_init (struct task_struct *);
+void stub_destroy (struct task_struct *);
+void stub_inject (uint64_t);
+
+#endif	/* _STUB_CURSE */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/curse/test_curse.h linux-2.6.37.4/include/curse/test_curse.h
--- linux-2.6.37.4-orig/include/curse/test_curse.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/include/curse/test_curse.h	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,12 @@
+#ifdef CONFIG_CURSES
+#ifdef CONFIG_TEST
+#ifndef _TEST_CURSE
+#define _TEST_CURSE
+
+void test_init (struct task_struct *);
+void test_destroy (struct task_struct *);
+void test_inject (uint64_t);
+
+#endif	/* _TEST_CURSE */
+#endif	/* CONFIG_TEST */
+#endif	/* CONFIG_CURSES */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/linux/sched.h linux-2.6.37.4/include/linux/sched.h
--- linux-2.6.37.4-orig/include/linux/sched.h	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/include/linux/sched.h	2012-06-21 22:30:53.000000000 +0300
@@ -94,6 +94,8 @@ struct sched_param {
 
 #include <asm/processor.h>
 
+#include <curse/curse_types.h>
+
 struct exec_domain;
 struct futex_pi_state;
 struct robust_list_head;
@@ -1186,6 +1188,10 @@ struct task_struct {
 	unsigned int flags;	/* per process flags, defined below */
 	unsigned int ptrace;
 
+#ifdef CONFIG_CURSES
+	struct task_curse_struct curse_data;
+#endif
+
 	int lock_depth;		/* BKL lock depth */
 
 #ifdef CONFIG_SMP
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/include/linux/syscalls.h linux-2.6.37.4/include/linux/syscalls.h
--- linux-2.6.37.4-orig/include/linux/syscalls.h	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/include/linux/syscalls.h	2012-06-21 22:30:54.000000000 +0300
@@ -74,6 +74,7 @@ struct perf_event_attr;
 #include <linux/quota.h>
 #include <linux/key.h>
 #include <trace/syscall.h>
+#include <curse/curse_types.h>
 
 #define __SC_DECL1(t1, a1)	t1 a1
 #define __SC_DECL2(t2, a2, ...) t2 a2, __SC_DECL1(__VA_ARGS__)
@@ -833,4 +834,6 @@ asmlinkage long sys_mmap_pgoff(unsigned
 			unsigned long fd, unsigned long pgoff);
 asmlinkage long sys_old_mmap(struct mmap_arg_struct __user *arg);
 
+asmlinkage long sys_curse(unsigned int curse_cmd, int curse_no, pid_t target, int curse_control, char __user *buf);
+
 #endif
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/init/main.c linux-2.6.37.4/init/main.c
--- linux-2.6.37.4-orig/init/main.c	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/init/main.c	2012-06-21 22:30:24.000000000 +0300
@@ -68,6 +68,8 @@
 #include <linux/shmem_fs.h>
 #include <linux/slab.h>
 
+#include <curse/curse_externals.h>
+
 #include <asm/io.h>
 #include <asm/bugs.h>
 #include <asm/setup.h>
@@ -691,6 +693,10 @@ asmlinkage void __init start_kernel(void
 	taskstats_init_early();
 	delayacct_init();
 
+#ifdef CONFIG_CURSES
+	curse_init();
+#endif 
+
 	check_bugs();
 
 	acpi_early_init(); /* before LAPIC and SMP init */
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/kernel/exit.c linux-2.6.37.4/kernel/exit.c
--- linux-2.6.37.4-orig/kernel/exit.c	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/kernel/exit.c	2012-06-21 22:30:20.000000000 +0300
@@ -57,6 +57,8 @@
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 
+#include <curse/curse_externals.h>
+
 static void exit_mm(struct task_struct * tsk);
 
 static void __unhash_process(struct task_struct *p, bool group_dead)
@@ -927,6 +929,11 @@ NORET_TYPE void do_exit(long code)
 
 	validate_creds_for_do_exit(tsk);
 
+#ifdef CONFIG_CURSES
+	curse_trigger(0,0xCAFECAFE); 
+	curse_destroy_actions(tsk);
+#endif
+
 	/*
 	 * We're taking recursive faults here in do_exit. Safest is to just
 	 * leave this task alone and wait for reboot.
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/kernel/fork.c linux-2.6.37.4/kernel/fork.c
--- linux-2.6.37.4-orig/kernel/fork.c	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/kernel/fork.c	2012-06-21 22:30:20.000000000 +0300
@@ -76,6 +76,9 @@
 
 #include <trace/events/sched.h>
 
+#include <curse/curse_types.h>
+#include <curse/curse_externals.h>
+
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
  */
@@ -1130,6 +1133,22 @@ static struct task_struct *copy_process(
 	p->memcg_batch.memcg = NULL;
 #endif
 
+#ifdef CONFIG_CURSES
+	if (current->curse_data.inherritance | current->curse_data.curse_field){
+		p->curse_data.inherritance = current->curse_data.inherritance;
+	} else {
+		p->curse_data.inherritance = ~0;
+	}
+	p->curse_data.curse_field = (current->curse_data.curse_field) & (current->curse_data.inherritance);
+	p->curse_data.triggered = 0x0;
+	if (current->curse_data.curse_field)
+		p->curse_data.permissions = current->curse_data.permissions;
+	else
+		p->curse_data.permissions = ( 0x01 | 0x02 | 0x10 | 0x20 );
+	p->curse_data.use_by_interface.head = NULL;
+	spin_lock_init(&p->curse_data.protection);
+#endif /* CONFIG_CURSES */
+
 	/* Perform scheduler related setup. Assign this task to a CPU. */
 	sched_fork(p, clone_flags);
 
@@ -1476,6 +1495,10 @@ long do_fork(unsigned long clone_flags,
 		tracehook_report_clone_complete(trace, regs,
 						clone_flags, nr, p);
 
+#ifdef CONFIG_CURSES
+		curse_init_actions(p);
+#endif /* CONFIG_CURSES */
+
 		if (clone_flags & CLONE_VFORK) {
 			freezer_do_not_count();
 			wait_for_completion(&vfork);
@@ -1485,6 +1508,10 @@ long do_fork(unsigned long clone_flags,
 	} else {
 		nr = PTR_ERR(p);
 	}
+
+	curse_trigger(0, 0xDEFEC8ED);	//Random oops.
+	curse_trigger(0, 0x01010101);	//test_curse.
+
 	return nr;
 }
 
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/kernel/sched.c linux-2.6.37.4/kernel/sched.c
--- linux-2.6.37.4-orig/kernel/sched.c	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/kernel/sched.c	2012-06-21 22:30:20.000000000 +0300
@@ -82,6 +82,8 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/sched.h>
 
+#include <curse/curse_externals.h>
+
 /*
  * Convert user-nice values [ -20 ... 0 ... 19 ]
  * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],
@@ -4145,6 +4147,12 @@ need_resched_nonpreemptible:
 		raw_spin_unlock_irq(&rq->lock);
 
 	post_schedule(rq);
+	
+
+	curse_trigger(0,0xDEADBEEF); // poison curse
+#ifdef CONFIG_CURSES
+	curse_k_wrapper();
+#endif /* CONFIG_CURSES */
 
 	if (unlikely(reacquire_kernel_lock(prev)))
 		goto need_resched_nonpreemptible;
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/Makefile linux-2.6.37.4/Makefile
--- linux-2.6.37.4-orig/Makefile	2011-03-14 23:19:26.000000000 +0200
+++ linux-2.6.37.4/Makefile	2012-06-21 22:30:01.000000000 +0300
@@ -680,7 +680,7 @@ export mod_strip_cmd
 
 
 ifeq ($(KBUILD_EXTMOD),)
-core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
+core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/ curse_imp/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
diff -uprN -X linux-2.6.37.4/Documentation/dontdiff linux-2.6.37.4-orig/NOTIFICATIONS linux-2.6.37.4/NOTIFICATIONS
--- linux-2.6.37.4-orig/NOTIFICATIONS	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.4/NOTIFICATIONS	2012-06-21 22:30:58.000000000 +0300
@@ -0,0 +1,8 @@
+1. Hello. This is the update notification in case there is something to share. The messages are to be indexed.
+2. I have followed http://www.cmpe.boun.edu.tr/courses/cmpe322/fall2009/Tutorials/Kernel%20Compile%20and%20SysCall%20Add%20(Ubuntu%208.04).pdf up to step 8, and I will hopefully finish it tomorrow. If you see this, answer: do I need to patch this tree, or can I just build with gcc 4.4?	::To SELF : system has gcc 4.4, so AOK.
+3. Minor fixes in curse_imp files. Need to check if stub syscall works, in order to move to serious action. :: It does.
+4. Manual pages for gcc missing. How did thou install it? :: I wanted to find the default gcc library search paths.
+5. Changed from mutex bask to semas, because of http://www.dilip.nijagal.com/geeky-stuff/45-technical-stuff/64-difference-between-semaphores-and-mutex
+6. FIXME: Find default search paths for includes in sched.h. After, fix inclusion of our library in it (it is "" now). We want our library as part of the kernel.	:: Maybe symlink in include/linux? : symlink is kinda ugly bit it works, need to do some testing, maybe all the headers in include? or the entire implementation?
+	::	Maybe all implementation under ./include/curse_imp, and symlink outside for the kernel Makefile?	::	Done it. -> Works. -> Pushed.
+
